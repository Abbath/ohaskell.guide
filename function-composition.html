<!DOCTYPE HTML>

<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="О Haskell по-человечески. Ваша первая книга о прекрасном и удивительном языке программирования.">
        <meta name="author" content="Денис Шевченко">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0">
        <title>
            Композиция функций &lt;- О Haskell по-человечески
        </title>
        <link rel="icon" href="./static/images/favicon.ico">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js">
            
        </script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.5/css/materialize.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.5/js/materialize.min.js">
            
        </script>
        <link rel="stylesheet" href="./static/css/default.css">
        <script src="./static/js/default.js">
            
        </script>
    </head>
    <body>
        <div class="navbar-fixed">
            <nav>
                <div class="nav-wrapper">
                    <a class="brand-logo center sans" href="./">
                        #ohaskell
                    </a>
                    <a href="#" data-activates="mobile-demo" class="button-collapse show-on-large" style="padding-left: 15px;">
                        <span class="fa fa-list-ul" style="font-size: 26px;">
                            
                        </span>
                    </a>
                    <ul class="side-nav sans" id="mobile-demo">
                        <li>
                            <a href="./init.html">
                                Добро пожаловать!
                            </a>
                        </li>
                        <li>
                            <a href="./haskell-faq.html">
                                Первые вопросы
                            </a>
                        </li>
                        <li>
                            <a href="./this-book.html">
                                Об этой книге
                            </a>
                        </li>
                        <li>
                            <a href="./setup.html">
                                Приготовимся
                            </a>
                        </li>
                        <li>
                            <a href="./whales-n-turtle.html">
                                Киты и Черепаха
                            </a>
                        </li>
                        <li>
                            <a href="./immutability-n-purity.html">
                                Неизменность и чистота
                            </a>
                        </li>
                        <li>
                            <a href="./if-n-return.html">
                                Выбираем и возвращаемся
                            </a>
                        </li>
                        <li>
                            <a href="./choose-n-patterns.html">
                                Выбор и образцы
                            </a>
                        </li>
                        <li>
                            <a href="./let-n-where.html">
                                Пусть будет там, Где...
                            </a>
                        </li>
                        <li>
                            <a href="./operators.html">
                                Мир операторов
                            </a>
                        </li>
                        <li>
                            <a href="./list.html">
                                Список: знакомство
                            </a>
                        </li>
                        <li>
                            <a href="./tuple.html">
                                Кортеж
                            </a>
                        </li>
                        <li>
                            <a href="./lambda-function.html">
                                Лямбда-функция
                            </a>
                        </li>
                        <li>
                            <a href="./function-composition.html">
                                Композиция функций
                            </a>
                        </li>
                        <li>
                            <a href="./hof.html">
                                ФВП
                            </a>
                        </li>
                        <li>
                            <a href="./list-generators.html">
                                Генераторы списков
                            </a>
                        </li>
                    </ul>
                    <ul id="nav-mobile" class="right">
                        <li>
                            <a href="https://github.com/denisshevchenko/ohaskell.guide" target="_blank">
                                <span class="fa fa-github">
                                    
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="mailto:me@dshevchenko.biz?Subject=#ohaskell,%20О%20книге" title="Написать автору">
                                <span class="fa fa-envelope-o">
                                    
                                </span>
                            </a>
                        </li>
                    </ul>
                </div>
            </nav>
        </div>
        <div class="container">
            <h1 id="композиция-функций">Композиция функций</h1>
<p>Эта глава рассказывает о том, как объединять функции в цепочки, а также о том, как избавиться от круглых скобок.</p>
<h2 id="скобкам-бой">Скобкам — бой!</h2>
<p>При всём уважении к Lisp-программистам, я не люблю круглые скобки. Они делают код визуально избыточным, к тому же нужно следить за симметрией скобок открывающих и закрывающих. Вспомним пример из главы про кортежи:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  putStrLn (patientEmail ( <span class="st">&quot;63ab89d&quot;</span>
           <span class="fu">^</span>             , <span class="st">&quot;John Smith&quot;</span>
                         , <span class="st">&quot;johnsm@gmail.com&quot;</span>
                         , <span class="dv">59</span>
                         ))
                          <span class="fu">^</span></code></pre></div>
<p>Со скобками кортежа мы ничего не можем сделать, ведь они являются частью кортежа. А вот скобки вокруг применения функции <code>patientEmail</code> мне абсолютно не нравятся. К счастью, мы можем избавиться от них. Но прежде чем искоренять скобки, задумаемся вот о чём.</p>
<p>Если применение функции представляет собой выражение, не можем ли мы как-нибудь компоновать их друг с другом? Конечно можем, мы уже делали это много раз, вспомните:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn (checkLocalhost <span class="st">&quot;173.194.22.100&quot;</span>)</code></pre></div>
<p>Здесь компонуются две функции, <code>putStrLn</code> и <code>checkLocalhost</code>, потому что тип выражения на выходе функции <code>checkLocalhost</code>, совпадает с типом выражения на входе функции <code>putStrLn</code>. Схематично это можно изобразить так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">         <span class="fu">+----------------+</span>            <span class="fu">+----------+</span>
<span class="dt">String</span> <span class="ot">-&gt;</span><span class="fu">|</span> checkLocalhost <span class="fu">|-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span><span class="fu">|</span> putStrLn <span class="fu">|-&gt;</span> <span class="fu">...</span>
         <span class="fu">+----------------+</span>            <span class="fu">+----------+</span></code></pre></div>
<p>Получается эдакий конвейер: на входе строка с IP-адресом, на выходе — сообщение в нашем терминале. Сущестует более лаконичный способ соединения двух функций воедино.</p>
<h2 id="композиция-и-применение">Композиция и применение</h2>
<p>Взгляните:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="fu">.</span> checkLocalhost <span class="fu">$</span> <span class="st">&quot;173.194.22.100&quot;</span></code></pre></div>
<p>Необычно? Перед нами два новых стандартных оператора, избавляющие нас от лишних скобок и делающие наш код проще. Оператор <code>.</code> — это оператор композиции функций (англ. function composition), а оператор <code>$</code> — это оператор применения (англ. application operator). Эти операторы часто используют совместно друг с другом.</p>
<p>Оператор композиции объединяет две функции воедино (или компонует их, англ. compose). Когда мы пишем:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn <span class="fu">.</span> checkLocalhost</code></pre></div>
<p>происходит маленькая «магия»: две функции объединяются в новую функцию. Вспомним наш конвейер:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">         <span class="fu">+----------------+</span>            <span class="fu">+----------+</span>
<span class="dt">String</span> <span class="ot">-&gt;</span><span class="fu">|</span> checkLocalhost <span class="fu">|-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span><span class="fu">|</span> putStrLn <span class="fu">|-&gt;</span> <span class="fu">...</span>
         <span class="fu">+----------------+</span>            <span class="fu">+----------+</span>

<span class="dt">A</span>                             <span class="dt">B</span>                       <span class="dt">C</span></code></pre></div>
<p>Раз нам нужно попасть из точки <code>A</code> в точку <code>C</code>, нельзя ли сделать это сразу? Можно, и в этом заключается суть композиции: мы берём две функции и объединяем их в третью функцию. Раз <code>checkLocalhost</code> приводит нас из точки <code>A</code> в <code>B</code>, а <code>putStrLn</code> — из точки <code>B</code> в <code>C</code>, то композиция этих двух функций будет представлять собой функцию, приводящую нас сразу из <code>A</code> в <code>C</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">         <span class="fu">+---------------------------+</span>
<span class="dt">String</span> <span class="ot">-&gt;</span><span class="fu">|</span> checkLocalhost <span class="fu">+</span> putStrLn <span class="fu">|-&gt;</span> <span class="fu">...</span>
         <span class="fu">+---------------------------+</span>

<span class="dt">A</span>                                        <span class="dt">C</span></code></pre></div>
<p>В данном случае знак <code>+</code> не относится к конкретному оператору, я лишь показываю факт «объединения» двух функций в третью. Разумеется, промежуточная точка <code>B</code> никуда не исчезла, просто она теперь скрыта от наших глаз.</p>
<p>И теперь нам стало понятнее, почему в типе функции, в качестве разделителя, используется стрелка:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">checkLocalhost ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

в нашем примере это<span class="fu">:</span>

<span class="ot">checkLocalhost ::</span> <span class="dt">A</span>      <span class="ot">-&gt;</span> <span class="dt">B</span></code></pre></div>
<p>Она показывает наше движение, из точки <code>A</code> в точку <code>B</code>. Поэтому часто говорят о «функции из <code>A</code> в <code>B</code>». Так, о функции <code>checkLocalhost</code> можно сказать как о «функции из <code>String</code> в <code>String</code>».</p>
<p>А оператор применения работает ещё проще. Без него код был бы таким:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  (putStrLn <span class="fu">.</span> checkLocalhost)  <span class="st">&quot;173.194.22.100&quot;</span>

  объединённая функция         аргумент</code></pre></div>
<p>Но мы ведь хотели избавиться от круглых скобок, а тут они опять. Вот для этого и нужен оператор применения:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span>
  putStrLn <span class="fu">.</span> checkLocalhost  <span class="fu">$</span>              <span class="st">&quot;173.194.22.100&quot;</span>

  объединённая функция       применяется к  аргументу</code></pre></div>
<p>Теперь получился настоящий конвейер: справа в него «заезжает» строка и едет «сквозь» функции, а слева «выезжает» результат:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn <span class="fu">.</span> checkLocalhost <span class="fu">$</span>  <span class="st">&quot;173.194.22.100&quot;</span>

       <span class="ot">&lt;-</span>       <span class="ot">&lt;-</span>               <span class="ot">&lt;-</span> аргумент</code></pre></div>
<p>Чтобы было легче читать композицию, вместо оператора <code>.</code> мысленно подставляем фразу «применяется после»:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putStrLn  <span class="fu">.</span>            checkLocalhost

эта       применяется  этой
функция   после        функции</code></pre></div>
<p>То есть композиция правоассоциативна: сначала применяется функция справа, а затем — слева. Красота композиции в том, что компоновать мы можем сколько угодно функций:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logWarn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
logWarn rawMessage <span class="fu">=</span>
  warning <span class="fu">.</span> correctSpaces <span class="fu">.</span> asciiOnly <span class="fu">$</span> rawMessage

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn <span class="fu">$</span> logWarn <span class="st">&quot;Province   'Gia Viễn' isn't on the map! &quot;</span></code></pre></div>
<p>Функция <code>logWarn</code> готовит переданную ей строку для записи в журнал. Функция <code>asciiOnly</code> готовит строку к выводу в нелокализованном терминале, функция <code>correctSpaces</code> убирает дублирующиеся пробелы, а функция <code>warning</code> делает строку предупреждением (например, добавляет строку “WARNING:” в начало сообщения). Таким образом, при запуске этой программы мы увидим:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">WARNING</span>: Province <span class="st">'Gia Vi?n'</span> isn<span class="st">'t on the map!</span></code></pre></div>
<p>Здесь мы объединили в «функциональный конвейер» уже три функции, безо всяких скобок. Более того, определение функции <code>logWarn</code> можно сделать ещё более простым:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">logWarn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
logWarn <span class="fu">=</span> warning <span class="fu">.</span> correctSpaces <span class="fu">.</span> asciiOnly</code></pre></div>
<p>Погодите, но где же имя аргумента? Его больше нет, оно нам не нужно. Вспомните, что применение функции может быть легко заменено внутренним выражением функции. А раз так, выражение <code>logWarn</code> может быть заменено на выражение <code>warning . correctSpaces . asciiOnly</code>. Сделаем же это:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">logWarn <span class="st">&quot;Province   'Gia Viễn' isn't on the map! &quot;</span> <span class="fu">=</span>
(warning
 <span class="fu">.</span> correctSpaces
 <span class="fu">.</span> asciiOnly) <span class="st">&quot;Province   'Gia Viễn' isn't on the map! &quot;</span> <span class="fu">=</span>
warning
<span class="fu">.</span> correctSpaces
<span class="fu">.</span> asciiOnly <span class="fu">$</span> <span class="st">&quot;Province   'Gia Viễn' isn't on the map! &quot;</span></code></pre></div>
<p>И всё работает! В мире Haskell принято именно так: если что-то может быть упрощено — мы это упрощаем.</p>
<h2 id="как-работает-композиция">Как работает композиция</h2>
<p>Если вдруг вы подумали, что оператор композиции уникален и встроен в Haskell — спешу вас разочаровать. Никакой магии, всё предельно просто. Этот оператор определён так же, как любая другая функция. Вот его определение:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">.</span>) f g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre></div>
<p>Опа! Да тут и вправду нет ничего особенного. Оператор композиции применяется к двум функциям. Стоп, скажете вы, как это? Применяется к функциям?? Да, именно так. Ведь мы уже выяснили, что функциями можно оперировать как данными. А раз так, что нам мешает передать функцию в качестве аргумента другой функции? Что нам мешает вернуть функцию из другой функции? Ничего.</p>
<p>Оператор композиции получает на вход две функции, а потом всего лишь даёт нам ЛФ, внутри которой происходит обыкновенный последовательный вызов этих двух функций через скобки. И никакой магии:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">.</span>)    f        g        <span class="fu">=</span>  \x <span class="ot">-&gt;</span> f (g x)

берём  эту      и эту       и возвращаем
       функцию  функцию     ЛФ, внутри
                            которой
                            вызываем их</code></pre></div>
<p>Подставим наши функции:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">.</span>) putStrLn checkLocalhost <span class="fu">=</span> \x <span class="ot">-&gt;</span> putStrLn (checkLocalhost x)</code></pre></div>
<p>Вот так и происходит «объединение» функций: мы просто возвращаем ЛФ от одного аргумента, внутри которой правоассоциативно вызываем обе функции. А аргументом и является та самая строка с IP-адресом:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\x <span class="ot">-&gt;</span> putStrLn (checkLocalhost x)) <span class="st">&quot;173.194.22.100&quot;</span> <span class="fu">=</span>
putStrLn (checkLocalhost <span class="st">&quot;173.194.22.100&quot;</span>))</code></pre></div>
<p>Теперь мы видим, что в композиции функций нет ничего сверхъестественного. Эту мысль я подчёркиваю на протяжении всей книги: в Haskell нет никакой магии, он логичен и последователен.</p>
<div style="padding-top: 45px;">
    
</div>
<div class="row">
    <div class="col s3">
        <div class="left">
            <a href="/lambda-function.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-left">
                    
                </span>
            </a>
        </div>
    </div>
    <div class="col s6">
        <div class="center-align">
            <button class="waves-effect waves-light btn blue lighten-2 show-comments sans">
                Обсудим?
            </button>
        </div>
    </div>
    <div class="col s3">
        <div class="right">
            <a href="/hof.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-right">
                    
                </span>
            </a>
        </div>
    </div>
</div>
<div style="padding-top: 20px;">
    
</div>
<div id="disqus_thread" style="padding-top: 30px;">
    
</div>

        </div>
    </body>
</html>
