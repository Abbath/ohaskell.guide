<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="О Haskell по-человечески. Книга о прекрасном и удивительном языке. Для обыкновенных программистов.">
        <meta name="author" content="Денис Шевченко">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />

        <link rel="icon" href="./static/images/favicon.ico">

        <title>#ohaskell</title>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>

        <!-- Compiled and minified CSS -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.5/css/materialize.min.css">

        <!-- Compiled and minified JavaScript -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.5/js/materialize.min.js"></script>

        <!-- Own css and js -->
        <link href="./static/css/default.css" rel="stylesheet">
        <script src="./static/js/default.js"></script>

        <script>
          window.___gcfg = {
            lang: 'ru'
          };
        </script>

        <script src="https://apis.google.com/js/platform.js" async defer>
        </script>
    </head>

    <body>
        <div class="navbar-fixed">
            <nav>
                <div class="nav-wrapper">
                    <a href="./" class="brand-logo center sans">
                        #ohaskell
                    </a>

                    <a href="#" data-activates="mobile-demo" class="button-collapse show-on-large" style="padding-left: 15px;">
                        <!-- <i class="material-icons">toc</i> -->
                        <i class="fa fa-list-ul" style="font-size: 30px;"></i>
                    </a>

                    <ul class="side-nav sans" id="mobile-demo">
                        <!-- % -->
                        <li><a href="./haskell-faq.html">Первые вопросы</a></li>
                        <li><a href="./this-book.html">Об этой книге</a></li>
                        <li><a href="./setup.html">Приготовимся</a></li>
                        <li><a href="./modules-minimum.html">Модули: знакомство</a></li>
                        <li><a href="./hackage.html">Hackage</a></li>
                        <li><a href="./expressions-n-functions.html">Мир выражений и функций</a></li>
                        <li><a href="./immutability-n-purity.html">Неизменность и чистота</a></li>
                        <li><a href="./functions-inside.html">Функции внутри</a></li>
                        <li><a href="./immutability.html">Функции: цепочки</a></li>
                        <li><a href="./immutability.html">Функции: лень</a></li>
                        <li><a href="./immutability.html">ФВП</a></li>
                        <li><a href="./immutability.html">Типы: знакомство</a></li>
                        <li><a href="./immutability.html">Типы: творим данные</a></li>
                        <li><a href="./immutability.html">Типы: творим типы</a></li>
                        <li><a href="./immutability.html">Классы: знакомство</a></li>
                        <li><a href="./immutability.html">Классы: творим</a></li>
                        <li><a href="./immutability.html">Функтор</a></li>
                        <li><a href="./immutability.html">Функтор: наш</a></li>
                        <li><a href="./immutability.html">Аппликативный функтор</a></li>
                        <li><a href="./immutability.html">Аппликативный функтор: наш</a></li>
                        <li><a href="./immutability.html">Монада</a></li>
                        <li><a href="./immutability.html">Монада: наша</a></li>
                        <li><a href="./immutability.html">Трансформер</a></li>
                        <li><a href="./immutability.html">Трансформер: наш</a></li>
                        <li><a href="./stackage.html">Stackage</a></li>
                        <li><a href="./immutability.html">Форматирование кода</a></li>
                        <li><a href="./immutability.html">Заключение</a></li>
                        <!-- % -->
                    </ul>

                    <ul id="nav-mobile" class="right">
                        <li><a href="https://github.com/denisshevchenko/ohaskell.guide" target="_blank"><span class="fa fa-github"></span></a></li>
                        <li><a href="mailto:me@dshevchenko.biz?Subject=#ohaskell,%20О%20книге" title="Написать автору"><span class="fa fa-envelope-o"></span></a></li>
                    </ul>
                </div>
            </nav>
        </div>

        <div class="container">
            <h1 id="неизменность-и-чистота">Неизменность и чистота</h1>
<p>В предыдущей главе мы познакомились с функциями и выражениями, увидев близкую связь этих понятий. В этой главе мы узнаем, что значит «чисто функциональный» язык и почему в нём нет места оператору присваивания.</p>
<h2 id="чисто-функциональный">Чисто функциональный?</h2>
<p>Haskell - чисто функциональный (англ. purely functional) язык. И суть этого понятия уже изложена в предыдущей главе, осталось лишь сформулировать.</p>
<p>Чисто функциональным называется такой язык, в котором центральное место уделено чистой функции (англ. pure function). А чистой она называется потому, что предельно честна с нами: её выходное значение всецело определяется её аргументами и более ничем. А ведь это и есть математическая функция! Вспомним <code>sum</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum x y <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div>
<p>Когда на входе <code>10</code> и <code>20</code> - на выходе всегда <code>30</code>, и ничто не способно помешать этому. Функция <code>sum</code> является чистой функцией, а потому характеризуется отсутствием побочных эффектов (англ. side effects). Именно поэтому чистая функция предельно надёжна: мы всегда можем заменить её применение её внутренним выражением, и результат останется неизменным. То есть если написано так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">square (sum <span class="dv">1</span> <span class="dv">2</span>)</code></pre></div>
<p>мы можем написать и так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">square (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</code></pre></div>
<p>Казалось бы, в других языках, например в C, функция тоже может быть чистой:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> sum(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> x + y;
}</code></pre></div>
<p>Однако это не совсем так. Да, результат функции <code>sum</code> здесь тоже определяется двумя аргументами, однако мы не можем гарантировать этого. И причиной тому являются переменные. Допустим:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> sum(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> x + y + <span class="fl">0.0049</span>;
}</code></pre></div>
<p>Мы ввели поправочный коэффициент <code>0.0049</code>, и теперь значение на выходе зависит (в том числе) и от него. Однако позже появилась другая функция, в теле которой понадобился тот же самый коэффициент. Мы, исповедуя принцип DRY (англ. Don’t Repeat Yourself, Не Повторяй Себя), вынесли коэффициент в отдельную переменную <code>coeff</code> и переписали функцию так:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> sum(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> x + y + coeff;
}</code></pre></div>
<p>Тут-то нас и поджидает проблема. Что будет, если значение <code>coeff</code> изменится в процессе работы программы? В этом случае и значение на выходе станет другим, поэтому мы, вызвав такую функцию с одинаковыми аргументами N раз, уже не можем быть полностью уверены в одинаковости результата. Хуже того, переменная <code>coeff</code> может оказаться глобальной, и её значение может изменяться совершенно другой функцией. В этом случае результат работы <code>sum</code> вполне может преподнести нам неприятный сюрприз, а потому она не может считаться чистой функцией.</p>
<p>Но, спросите вы, разве в Haskell мы не можем вынести общее значение в такой же <code>coeff</code>? Можем, но функция <code>sum</code> гарантированно останется чистой. И причина тому - неизменность данных (англ. data immutability).</p>
<h2 id="присваивание-не-не-слышал">«Присваивание? Не, не слышал…»</h2>
<p>В мире Haskell нет места оператору присваивания. Этот факт, удивительный на первый взгляд, предельно логичным, если мы помним о математической природе функций в Haskell. Если каждая функция в конечном итоге представляет собою некое выражение, вычисляемое посредством применения каких-то других функций к каким-то другим аргументам - тогда нам просто не нужно ничего ничему присваивать.</p>
<p>Вспомним, что присваивание (англ. assignment) пришло к нам из императивных языков. Суть императивного программирования (англ. imperative programming) в том, что программа воспринимается как набор инструкций, работа которых неразрывно связана с изменением состояния этой программы. Вот почему в императивных языках обязательно присутствует понятие «переменная». А раз есть переменные - должен быть и инструмент для изменения их значений, а именно оператор присваивания. Когда мы пишем:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">coeff = <span class="fl">0.569</span>;</code></pre></div>
<p>мы тем самым приказываем: «Возьми значение <code>0.569</code> и перезапиши им то значение, которое уже содержалось в переменной <code>coeff</code> до этого». И перезаписывать это значение мы можем множество раз, а следовательно, мы вынуждены внимательно отслеживать текущее состояние переменной <code>coeff</code>.</p>
<p>Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Haskell воплотил в себе именно этот подход, при котором программа воспринимается уже не как набор инструкций, а как набор выражений. И поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Любое конкретное значение в Haskell-программе, будучи созданным единожды, уже не может быть изменено, никогда и никем. Поэтому когда в Haskell-коде мы пишем:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">coeff <span class="fu">=</span> <span class="fl">0.569</span>;</code></pre></div>
<p>мы просто объявляем/декларируем: «Отныне значение <code>coeff</code> равно <code>0.569</code>, и так оно будет всегда». В этом случае функции, использующие <code>coeff</code>, уже не способны преподнести нам сюрприз. Когда вы видите в Haskell-коде символ <code>=</code> - перед вам объявление равенства, а вовсе не присваивание.</p>
<p>Вы спросите, как же можно написать реальную программу на языке, в котором нельзя изменять данные? Оказывается, можно. Да, нам не дано изменить уже созданное значение, однако мы можем создать на его основе новое значение. А обязанности по уничтожению уже не нужных данных возложены на встроенный в Haskell сборщик мусора (англ. garbage collector).</p>
<h2 id="порядок-вычислений">Порядок вычислений</h2>
<p>Императивный подход к разработке характеризуется ещё одним свойством, а именно жёстким порядком вычислений. Когда программа представляет собой набор инструкций, изменяющих состояние переменных, тогда и порядок выполнения этих инструкций жёстко задаётся программистом. Например:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main() {
    <span class="dt">int</span> result1 = sum(<span class="dv">10</span>, <span class="dv">20</span>);
    <span class="dt">int</span> result2 = mul(<span class="dv">30</span>, <span class="dv">40</span>);
    <span class="co">/* Что-то делаем с результатами result1 и result2. */</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Здесь функция <code>mul</code> делает почти то же, что и <code>sum</code>, только возвращает произведение двух аргументов, а не сумму. Вопрос: в каком порядке будут вызваны функции <code>sum</code> и <code>mul</code>? В том, в каком написаны: сначала <code>sum</code>, а потом <code>mul</code>.</p>
<p>При декларативном же подходе порядок вызова чистых функций нам, во-первых, не всегда известен, а во-вторых - и это главное! - он нам неинтересен.</p>
<p>Погодите, возразите вы, как это не всегда известен?! А вот так. Природа чистых функций такова, что нам больше не нужно думать о порядке вызова функций наподобие <code>sum</code> и <code>mul</code>, ведь результат их вычислений в конечном итоге окажется гарантированно правильным.</p>
<p>Я знаю, это удивляет. Мы привыкли давать чёткие приказания в нашем коде: «Сейчас вызови эту функцию, потом измени значение той переменной, после чего вызови вон ту функцию». То есть мы сфокусированы на том, <strong>как</strong> работает наша программа. А в декларативном мире мы не хотим думать о том, как работает наша программа, мы думаем лишь о том, <strong>что</strong> она в итоге сделает. Мы сфокусированы не на процессе вычислений, а на их результате, не на последовательности шагов, а на том, к чему они нас приведут.</p>
<p>Уверен, у вас уже уйма вопросов. Не спешите задавать их - по мере чтения книги всё встанет на свои места, и очень скоро вы убедитесь в том, что можно прекрасно обходиться без оператора присваивания.</p>

<div style="padding-top: 45px;"><div>
<div class="row">
    <div class="col s3">
        <div class="left">
            <a href="/expressions-n-functions.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-left"></span>
            </a>
        </div>
    </div>

    <div class="col s6">
        <div class="center-align">
            <!-- An element a visitor can click if they <3 comments! -->
            <button class="waves-effect waves-light btn blue lighten-2 show-comments sans">
                Обсудим?
            </button>
        </div>
    </div>

    <div class="col s3">
        <div class="right">
            <a href="/functions-inside.html" class="btn waves-effect waves-light chapter-arrow">
                <span class="fa fa-angle-double-right"></span>
            </a>
        </div>
    </div>
</div>
<div style="padding-top: 20px;"><div>

<!-- The empty element required for Disqus to loads comments into -->
<div id="disqus_thread" style="padding-top: 30px;"></div>

<!--
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ohaskell'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
-->


        </div>
    </body>
</html>
