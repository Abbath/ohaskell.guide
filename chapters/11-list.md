# Список

Пам'ятаєте, в одному з попередніх розділів я говорив, що познайомлю вас ще з кількома стандартними типами даних в Haskell? Настав час дізнатися про списки.

Список (англ. list) &mdash; це стандартний тип, що характеризує вже не просто дані, але структуру даних (англ. data structure). Ця структура є набором даних одного типу, і навряд чи хоч одна реальна Haskell-програма може обійтися без списків.

Структури, що містять дані одного типу, називають гомогенними (в перекладі з грецької: &laquo;одного роду&raquo;).

Ось список з трьох цілих чисел:

```haskell
[1, 2, 3]
```

Квадратні дужки, і значення, розділені комами. Ось так виглядає список з двох значень типу `Double`:

```haskell
[1.3, 45.7899]
```

а ось і список з одного-єдиного символу:

```haskell
['H']
```

або ось з чотирьох рядків, що відображають імена протоколів транспортного рівня OSI-моделі:

```haskell
["TCP", "UDP", "DCCP", "SCTP"]
```

Якщо у вас є досвід розробки на мові C, ви можете подумати, що список схожий на масив. Однак, хоча подібності є, я навмисно уникаю слова &laquo;масив&raquo;, тому що в Haskell існують масиви (англ. array), це дещо інша структура даних.

Список &mdash; це теж вираз, тому можна легко створити список списків довільної вкладеності. Ось так буде виглядати список з ряду протоколів трьох рівнів OSI-моделі:

```haskell
[ ["DHCP", "FTP", "HTTP"]
, ["TCP", "UDP", "DCCP", "SCTP"]
, ["ARP", "NDP", "OSPF"]
]
```

Це список списків рядків. Форматування щодо квадратних дужок досить вільне, при бажанні можна і так написати:

```haskell
[["DHCP", "FTP", "HTTP" ],
["TCP", "UDP", "DCCP", "SCTP"],
["ARP", "NDP", "OSPF" ]]
```

Список може бути порожнім, тобто не містити в собі ніяких даних:

```haskell
[]
```

## Тип списку

Раз список є структурою, що містить дані деякого типу, який же тип самого списку? Ось:

```haskell
[Int] -- Список цілих чисел
[Char] -- Список символів
[String] -- Список рядків
```

Тобто тип списку так і вказується у квадратних дужках. Згаданий раніше список списків рядків має такий вигляд:

```haskell
[[String]] -- Список списків рядків
```

Модель дуже проста:

```haskell
[   [String]  ]

    | Тип  |
    |даних |
 
|  Тип        |
|  списку     |
|_ цих даних _|
```

Зберігати дані різних типів в стандартному списку неможливо. Однак незабаром ми познайомимося з іншою стандартною структурою даних, яка це дозволяє.

## Дії над списками

Якщо списки створюються &mdash; значить це комусь потрібно. Зі списком можна робити дуже багато всього. У стандартній Haskell-бібліотеці існує окремий модуль `Data.List`, що включає широкий набір функцій, що працюють зі списком. Відкриємо модуль `Main` і імпортуємо в нього модуль `Data.List`:

```haskell
module Main where

-- Стандартний модуль для роботи зі списками.
import Data.List

main :: IO ()
main = putStrLn (head ["Vim", "Emacs", "Atom"])
```

Функція `head` повертає голову списку, тобто його перший елемент. При запуску цієї програми на виході отримаємо:

```bash
Vim
```

Модель така:

```haskell
["Vim"  , "Emacs", "Atom"]

 голова   |___ хвіст ___|
```

Така собі гусениця виходить: перший елемент &mdash; голова, а все інше &mdash; хвіст. Функція `tail` повертає хвіст:

```haskell
main :: IO ()
main = print (tail ["Vim", "Emacs", "Atom"])
```

Ось результат:

```bash
["Emacs", "Atom"]
```

Функція `tail` формує інший список, який представляє собою все від початкового списку, крім голови. Зверніть увагу на нову функцію `print`. В даному випадку ми не могли б використовувати нашу знайому `putStrLn`, адже вона застосовується до значенm типу `String`, в той час як функція `tail` поверне нам значення типу `[String]`. Адже ми пам'ятаємо про строгість компілятора: що очікуємо, то і повинні отримати. Функція `print` призначена для &laquo;стрінгіфікації&raquo; значень: вона бере значення деякого типу і виводить це значення на консоль у вигляді рядка.

Уважний читач запитає, яким же чином функція `print` дізнається, як саме відобразити конкретне значення у вигляді рядка? О, це цікава тема, але вона відноситься до Третього Кита Haskell, до знайомства з яким нам ще далеко.

Можна отримати довжину списку:

```haskell
handleTableRow :: String -> String
handleTableRow row
  | length row == 2 = composeTwoOptionsFrom row
  | length row == 3 = composeThreeOptionsFrom row
  | otherwise = invalidRow row
```

Це трішки видозмінений шматочок однієї моєї програми, функція `handleTableRow` обробляє рядок таблиці. Стандартна функція `length` дає нам довжину списку (число елементів у ньому). В даному випадку ми дізнаємося кількість елементів у рядку таблиці `row`, і залежно від цієї довжини застосовуємо до цього рядка функцію `composeTwoOptionsFrom` або `composeThreeOptionsFrom`.

Але стривайте, а де ж тут список? Функція `handleTableRow` застосовується до рядку і обчислює рядок. А вся справа в тому, що рядок є ніщо інше, як список символів. Тобто тип `String` еквівалентний типу `[Char]`. Скажу більше: `String` &mdash; це навіть не самостійний тип, це всього лише псевдонім для типу `[Char]`, і ось як він заданий:

```haskell
type String = [Char]
```

Ключове слово `type` вводить псевдонім для вже існуючого типу. Читається так:

```haskell
type String =        [Char]

тип  цей    дорівнює тому
```

Таким чином, оголошення функції `handleTableRow` можна було б переписати так:

```haskell
handleTableRow :: [Char] -> [Char]
```

При роботі зі списками ми можемо використовувати вже знайомі проміжні вирази, наприклад:

```haskell
handleTableRow :: String -> String
handleTableRow row
  | size == 2 = composeTwoOptionsFrom row
  | size == 3 = composeThreeOptionsFrom row
  | otherwise = invalidRow row
  where size = length row
```

А можна і так:

```haskell
handleTableRow :: String -> String
handleTableRow row
  | twoOptions = composeTwoOptionsFrom row
  | threeOptions = composeThreeOptionsFrom row
  | otherwise = invalidRow row
  where
    size = length row -- Дізнаємося довжину
    twoOptions = size == 2 -- порівнюємо ... 
    threeOptions = size == 3 -- ... і ще раз
```

Тут вирази `twoOptions` і `threeOptions` мають вже знайомий нам стандартний тип `Bool`, адже вони дорівнюють результату порівняння значення `size` з числом.

## Незмінність списку

Як ви вже знаєте, всі дані в Haskell незмінні, як Єгипетські піраміди. Списки &mdash; не виняток: ми не можемо змінити існуючий список, ми можемо лише створити на його основі новий список. Наприклад:

```haskell
addTo :: String -> [String] -> [String]
addTo newHost hosts = newHost : hosts

main :: IO ()
main = print ("124.67.54.90" `addTo` hosts)
where hosts = ["45.67.78.89", "123.45.65.54"]
```

Результат цієї програми такий:

```bash
["124.67.54.90","45.67.78.89","123.45.65.54"]
```

Розглянемо визначення функції `addTo`:

```haskell
addTo newHost hosts = newHost : hosts
```

Стандартний оператор `:` додає значення, що є лівим операндом, в початок списку, що є правим операндом. Читається так:

```haskell
newHost :        hosts

        цей
        оператор

бере
це
значення
                 і додає
                 його на початок
                 цього списку
```

Природно, тип значення зліва зобов'язаний співпадати з типом значень, що містяться в списку праворуч.

З концептуальної точки зору функція `addTo` додала нову IP-адресу в початок списку `host`. У дійсності ж ніякого додавання не сталося, бо списки незмінні. Оператор `:` взяв значення `newHost` та список `host` і створив на їх основі новий список, який містить в собі вже три IP-адреси замість двох.

## Переліки

Припустимо, що нам знадобився список цілих чисел від одного до десяти. Пишемо:

```haskell
main :: IO ()
main = print tenNumbers
  where tenNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Непогано, але надмірно, адже чисел могло бути сто, тисяча. Є кращий шлях:

```haskell
main :: IO ()
main = print tenNumbers
  where tenNumbers = [1..10]
```

Красиво, чи не так? Вираз у квадратних дужках називається переліком (англ. enumeration або скорочено enum). Іноді його називають також арифметичною послідовністю. Ідея гранично проста: навіщо вказувати вміст списку цілком у тій ситуації, коли можна вказати лише діапазон значень? Це ми і зробили:

```haskell
[1..10] = [1,2,3,4,5,6,7,8,9,10]
```

Значення зліва від `..` &mdash; це початок діапазону, а значення праворуч &mdash; його кінець. Компілятор сам здогадається, що крок між числами в даній послідовності дорівнює 1. Ось ще приклад:

```haskell
[3..17] = [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]

_          _

    ==                                        ==
```

Ми можемо задати крок і явно:

```haskell
[2,4..10] = [2,4,6,8,10]
```

Отримали тільки парні значення. Схема проста:

```haskell
[2,       4 ..   10    ]

перший           кінець
          другий

|  різниця   |
|_ дає крок _|
```

Ось ще приклад:

```haskell
[3,9..28] = [3,9,15,21,27]
```

Можна задати і спадний діапазон:

```haskell
[9,8..1] = [9,8,7,6,5,4,3,2,1]
```

Або так:

```haskell
[-9,-8..-1] = [-9,-8,-7,-6,-5,-4,-3,-2,-1]
```

Так, негативні числа теж працюють. Можна взяти також і числа з плаваючою точкою:

```haskell
[1.02,1.04..1.16] = [1.02,1.04,1.06,1.08,1.1,1.12,1.14,1.16]
```

Загалом, ідея зрозуміла. Але що це ми весь час з числами та з числами! Візьмемо символи:

```haskell
['a'..'z'] = "abcdefghijklmnopqrstuvwxyz"
```

Діапазон від `a" до `z" &mdash; отримали англійський алфавіт у вигляді `[Char]` або, як ми вже знаємо, просто `String`. При великому бажанні явно задати крок можна і тут:

```haskell
['a','c'..'z'] = "acegikmoqsuwy"
```

Ось така краса.

Тепер, після знайомства зі списками, ми будемо використовувати їх постійно.

## Для допитливих

У розділі про діапазони для списку ми оперували значеннями типу `Int`, `Double` і `Char`. Виникає питання: а чи можна використовувати значення якихось інших типів? Відповідаю: можна, але із застереженням. Спробуємо зробити це з рядком:

``haskell
main :: IO ()
main = print ["a","aa".."aaaaaa"] -- Ну-ну...
``

При спробі зібрати такий код побачимо помилку:

``bash
No for instance (Enum [Char])
arising from the arithmetic sequence '"a", "aa" .. "aaaaaa"'
``

І дивуватися тут нічому: крок між рядками абсурдний, і компілятор розгублений. Не всі типи підходять для переліків через своєю природу, однак у майбутньому, коли ми навчимося створювати наші власні типи, ми дізнаємося, що їх цілком можна використовувати в діапазонах. Наберіться терпіння.
