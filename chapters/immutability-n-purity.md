# Неизменность и чистота

В предыдущей главе мы познакомились с функциями и выражениями, увидев близкую связь этих понятий. В этой главе мы узнаем, что значит &laquo;чисто функциональный&raquo; язык и почему в нём нет места оператору присваивания.

## Чисто функциональный?

Haskell - чисто функциональный (англ. purely functional) язык. И суть этого понятия уже изложена в предыдущей главе, осталось лишь сформулировать.

Чисто функциональным называется такой язык, в котором центральное место уделено чистой функции (англ. pure function). А чистой она называется потому, что предельно честна с нами: её выходное значение всецело определяется её аргументами и более ничем. А ведь это и есть математическая функция! Вспомним `sum`:

```haskell
sum x y = x + y
```

Когда на входе `10` и `20` - на выходе всегда `30`, и ничто не способно помешать этому. Функция `sum` является чистой функцией, а потому характеризуется отсутствием побочных эффектов (англ. side effects). Именно поэтому чистая функция предельно надёжна: мы всегда можем заменить её применение её внутренним выражением, и результат останется неизменным. То есть если написано так:

```haskell
square (sum 1 2)
```

мы можем написать и так:

```haskell
square (1 + 2)
```

Казалось бы, в других языках, например в C, функция тоже может быть чистой:

```c
int sum(int x, int y) {
    return x + y;
}
```

Однако это не совсем так. Да, результат функции `sum` здесь тоже определяется двумя аргументами, однако мы не можем гарантировать этого. И причиной тому являются переменные. Допустим:

```c
int sum(int x, int y) {
    return x + y + 0.0049;
}
```

Мы ввели поправочный коэффициент `0.0049`, и теперь значение на выходе зависит (в том числе) и от него. Однако позже появилась другая функция, в теле которой понадобился тот же самый коэффициент. Мы, исповедуя принцип DRY (англ. Don't Repeat Yourself, Не Повторяй Себя), вынесли коэффициент в отдельную переменную `coeff` и переписали функцию так:

```c
int sum(int x, int y) {
    return x + y + coeff;
}
```

Тут-то нас и поджидает проблема. Что будет, если значение `coeff` изменится в процессе работы программы? В этом случае и значение на выходе станет другим, поэтому мы, вызвав такую функцию с одинаковыми аргументами N раз, уже не можем быть полностью уверены в одинаковости результата. Хуже того, переменная `coeff` может оказаться глобальной, и её значение может изменяться совершенно другой функцией. В этом случае результат работы `sum` вполне может преподнести нам неприятный сюрприз, а потому она не может считаться чистой функцией.

Но, спросите вы, разве в Haskell мы не можем вынести общее значение в такой же `coeff`? Можем, но функция `sum` гарантированно останется чистой. И причина тому - неизменность данных (англ. data immutability).

## &laquo;Присваивание? Не, не слышал&hellip;&raquo;

В мире Haskell нет места оператору присваивания. Этот факт, удивительный на первый взгляд, предельно логичным, если мы помним о математической природе функций в Haskell. Если каждая функция в конечном итоге представляет собою некое выражение, вычисляемое посредством применения каких-то других функций к каким-то другим аргументам - тогда нам просто не нужно ничего ничему присваивать.

Вспомним, что присваивание (англ. assignment) пришло к нам из императивных языков. Суть императивного программирования (англ. imperative programming) в том, что программа воспринимается как набор инструкций, работа которых неразрывно связана с изменением состояния этой программы. Вот почему в императивных языках обязательно присутствует понятие &laquo;переменная&raquo;. А раз есть переменные - должен быть и инструмент для изменения их значений, а именно оператор присваивания. Когда мы пишем:

```c
coeff = 0.569;
```

мы тем самым приказываем: &laquo;Возьми значение `0.569` и перезапиши им то значение, которое уже содержалось в переменной `coeff` до этого&raquo;. И перезаписывать это значение мы можем множество раз, а следовательно, мы вынуждены внимательно отслеживать текущее состояние переменной `coeff`.

Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Haskell воплотил в себе именно этот подход, при котором программа воспринимается уже не как набор инструкций, а как набор выражений. И поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Любое конкретное значение в Haskell-программе, будучи созданным единожды, уже не может быть изменено, никогда и никем. Поэтому когда в Haskell-коде мы пишем:

```haskell
coeff = 0.569;
```

мы просто объявляем/декларируем: &laquo;Отныне значение `coeff` равно `0.569`, и так оно будет всегда&raquo;. В этом случае функции, использующие `coeff`, уже не способны преподнести нам сюрприз. Когда вы видите в Haskell-коде символ `=` - перед вам объявление равенства, а вовсе не присваивание.

Вы спросите, как же можно написать реальную программу на языке, в котором нельзя изменять данные? Оказывается, можно. Да, нам не дано изменить уже созданное значение, однако мы можем создать на его основе новое значение. А обязанности по уничтожению уже не нужных данных возложены на встроенный в Haskell сборщик мусора (англ. garbage collector).

## Порядок вычислений

Императивный подход к разработке характеризуется ещё одним свойством, а именно жёстким порядком вычислений. Когда программа представляет собой набор инструкций, изменяющих состояние переменных, тогда и порядок выполнения этих инструкций жёстко задаётся программистом. Например:

```c
int main() {
    int result1 = sum(10, 20);
    int result2 = mul(30, 40);
    /* Что-то делаем с результатами result1 и result2. */
    return 0;
}
```

Здесь функция `mul` делает почти то же, что и `sum`, только возвращает произведение двух аргументов, а не сумму. Вопрос: в каком порядке будут вызваны функции `sum` и `mul`? В том, в каком написаны: сначала `sum`, а потом `mul`.

При декларативном же подходе порядок вызова чистых функций нам, во-первых, не всегда известен, а во-вторых - и это главное! - он нам неинтересен.

Погодите, возразите вы, как это не всегда известен?! А вот так. Природа чистых функций такова, что нам больше не нужно думать о порядке вызова функций наподобие `sum` и `mul`, ведь результат их вычислений в конечном итоге окажется гарантированно правильным.

Я знаю, это удивляет. Мы привыкли давать чёткие приказания в нашем коде: &laquo;Сейчас вызови эту функцию, потом измени значение той переменной, после чего вызови вон ту функцию&raquo;. То есть мы сфокусированы на том, **как** работает наша программа. А в декларативном мире мы не хотим думать о том, как работает наша программа, мы думаем лишь о том, **что** она в итоге сделает. Мы сфокусированы не на процессе вычислений, а на их результате, не на последовательности шагов, а на том, к чему они нас приведут.

Уверен, у вас уже уйма вопросов. Не спешите задавать их - по мере чтения книги всё встанет на свои места, и очень скоро вы убедитесь в том, что можно прекрасно обходиться без оператора присваивания.

