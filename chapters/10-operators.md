# Світ Операторів

Оператор (англ. operator) &mdash; особливий випадок функції. У попередніх розділах ми вже познайомилися з ними, залишилося пояснити докладніше.

Згадаймо наш найперший вираз:

```haskell
1 + 2
```

Функція `+` записана в інфиксній (англ. infix) формі, тобто між своїми аргументами. Такий запис виглядає природніше, ніж звичайний:

```haskell
(+) 1 2
```

Бачите круглі дужки? Вони говорять про те, що дана функція призначена для інфиксного запису. Автор цієї функції спочатку розраховував на інфіксну форму використання `1 + 2`, а не на звичайну `(+) 1 2`, саме тому ім'я функції у визначенні обрамлене в круглі дужки:

```haskell
(+) :: ...
```

Функції, призначені для інфіксної форми застосування, називають операторами.

Якщо ж ім'я функції не обрамлене в круглі дужки, мається на увазі, що ми розраховуємо на звичайну форму її застосування. Однак і в цьому випадку можна застосовувати її інфіксно, але ім'я повинно лежати в зворотнії одинарних лапках (англ. backtick).

Визначимо функцію `isEqualTo`, що є аналогом оператора перевірки на рівність для двох цілочисельних значень:

```haskell
isEqualTo :: Int -> Int -> Bool
isEqualTo x y = x == y
```

При звичайній формі її застосування виглядало би так:

```haskell
  ...
  if isEqualTo code1 code2 then ... else ...
  where code1 = 123
        code2 = 124
...
```

Але давайте перепишемо у інфіксній формі:

```haskell
  ...
  if code1 `isEqualTo` code2 then ... else ...
  where code1 = 123
        code2 = 124
...
```

Набагато краще, адже тепер код читається як звичайний англійський текст:

```haskell
  ...
  if code1 `isEqualTo` code2 ...
  if code1 is equal to code2 ...
  ...
```

Строго кажучи, назва &laquo;оператор&raquo; вельми умовна, ми можемо її і не використовувати. Говорити про функції додавання настільки ж коректно, як і про оператор додавання.

## Навіщо це потрібно?

Майже всі ASCII-символи (а також їх різноманітні комбінації) можна використовувати в якості операторів в Haskell. Це дає нам широкі можливості для реалізації різних EDSL (англ. Embedded Domain Specific Language), свого роду &laquo;мов у мові&raquo;. Ось приклад:

```haskell
div ! class_ "nav-wrapper" $
  a ! class_ "brand-logo sans" ! href/" $
    "#ohaskell"
```

Кожен, хто знайомий з веб-розробкою, миттєво впізнає в цьому коді HTML. Цей [шматочок коду](https://github.com/Abbath/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56), будує HTML-шаблон для веб-варіанту даної книги. Те що ви бачите &mdash; це абсолютно легальний Haskell-код, в процесі роботи якого генерується реальний HTML: тег `<div>` з класом `nav-wrapper`, всередині якого лежить `<a>`-посилання з двома класами, кореневj. адресою і внутрішнім текстом `#ohaskell`.

Ідентифікатори `div`, `class_` і `href` &mdash; це імена функцій, а символи `!` і `$` &mdash; це оператори, записані в інфіксній формі. Найголовніше, що для розуміння цього коду нам абсолютно необов'язково знати, де визначені всі ці функції/оператори і як вони працюють. Це важлива думка, яку я неодноразово буду повторювати у наступних розділах:

> Щоб використовувати функції, нам зовсім необов'язково знати їх внутрішню будову.

А про EDSL пам'ятайте, ми з ними ще зустрінемося.
