# Функції Вищого Порядку

ФВП, або Функції Вищого Порядку (англ. HOF, Higher Order Functions) &mdash; важлива концепція в Haskell, з якою, однак, ми вже знайомі. Як ми дізналися з попередніх розділів, функціями можна оперувати як значеннями. Так от, функції, які оперують іншими функціями як аргументами і/або як результуючим вираженням, мають назву функцій вищого порядку.

Так, оператор композиції функцій є ФВП, тому що він, по-перше, приймає функції в якості аргументів, а по-друге, повертає іншу функцію (у вигляді ЛФ) як результат свого застосування. Використання функцій в якості аргументів &mdash; надзвичайно поширена практика в Haskell.

## Відображення

Розглянемо функцію `map`. Ця стандартна функція використовується для відображення (англ. mapping) функції на елементи списку. Нехай вас не бентежить такий термін: відображення функції на елемент фактично означає її застосування до елемента.

Ось оголошення функції `map`:

```haskell
map :: (a -> b) -> [a] -> [b]
```

Ось знову ці маленькі літери! Пам'ятаєте, я обіцяв розповісти про них? Розповідаю: малою літерою прийнято іменувати поліморфний (англ. polymorphic) тип. Поліморфізм &mdash; це різноманітність, багатоформенність. В даному випадку мова йде не про зазначення конкретного типу, а про &laquo;типову заглушку&raquo;. Ми говоримо: &laquo;Функція `map` застосовується до функції з якогось типу `a` в якийсь тип `b` і до списку типу `[a]`, а результат її роботи &mdash; це інший список типу `[b]`&raquo;. Типовими заглушками я назвав їх тому, що на їхнє місце стають конкретні типи, що робить функцію `map` дуже гнучкою. Наприклад:

```haskell
import Data.Char

toUpperCase :: String -> String
toUpperCase str = map toUpper str

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org"
```

Результатом роботи цієї програми буде рядок:

```bash
HASKELL.ORG
```

Функція `map` застосовується до двох аргументів: до функції `toUpper` і рядка `str`. Функція `toUpper` зі стандартного модуля `Data.Char` переводить символ типу `Char` верхній регістр:

```haskell
toUpper 'a' = 'A'
```

Ось її оголошення:

```haskell
toUpper :: Char -> Char
```

Функція `Char` в `Char` виступає першим аргументом функції `map`, підставимо сигнатуру:

```haskell
map :: (a -> b) -> [a] -> [b]
       (Char -> Char)
```

Ага, вже тепліше! Ми зробили два нових відкриття: по-перше, заглушки `a` і `b` можуть бути зайняті одним і тим самим конкретним типом, а по-друге, сигнатура дозволяє нам тут же зрозуміти інші типи. Підставимо їх:

```haskell
map :: (a -> b)       -> [a]    -> [b]
       (Char -> Char)    [Char]    [Char]

        ____              ____
 
                ____                ____
```

А тепер згадаємо про природу типу `String`:

```haskell
map :: (a -> b)       -> [a]    -> [b]
       (Char -> Char)    String    String
```

Все стало на свої місця. Функція `map` в даному випадку бере функцію `toUpper` і біжить по списку, послідовно застосовуючи цю функцію до його елементів:

```haskell
map toUpper ['h','a','s','k','e','l','l','.','o','r','g']
```

Так, на першому кроці функція `toUpper` буде застосована до елементу `h`, на другому &mdash; до елементу `a`, і так далі до останнього елемента `g`. Коли функція `map` біжить по цьому списку, результат застосування функції `toUpper` до його елементів стає елементами другого списку, який і буде в кінцевому підсумку повернуто. Так, результатом першого кроку буде елемент `H`, результатом другого &mdash; елемент `A`, а результатом останнього &mdash; елемент `G`. Схема така:

```haskell
map toUpper [ 'h' >> [ 'H'
            , 'a' >> , 'A'
            , 's' >> , 'S'
            , 'k' >> , 'K'
            , 'e' >> , 'E'
            , 'l' >> , 'L'
            , 'l' >> , 'L'
            , '.' >> , '.'
            , 'o' >> , 'O'
            , 'r' >> , 'R'
            , 'g' >> , 'G'
            ]        ]
```

Ось і виходить:

```haskell
map toUpper "haskell.org" = "HASKELL.ORG"
```

Робота функції `map` виглядає як зміна списку, однак, маючи на увазі незмінність останнього, насправді формується новий список. Що найцікавіше, функція `toUpper` перебуває в повному незнанні про те, що нею в кінцевому підсумку змінюють регістр цілого рядка, вона знає лише про окремі символи рядка. Тобто функція, що є аргументом функції `map`, нічого не знає про функцію `map`, і це дуже добре! Чим менше функції знають одна про одну, тим простіше і надійніше використовувати їх одну з одною.

Розглянемо інший приклад, коли типові заглушки `a` і `b` заміщуються різними типами:

```haskell
toStr :: [Double] -> [String]
toStr numbers = show map numbers

main :: IO ()
main = print . toStr $ [1.2, 1,4, 1.6]
```

Функція `toStr` працює вже зі списками різних типів: на вході список чисел з плаваючою крапкою, на виході список рядків. При запуску цієї програми ми побачимо наступне:

```bash
["1.2","1.0","4.0","1.6"]
```

Вже знайома нам стандартна функція `show` перетворює свій єдиний аргумент в рядковий вигляд:

```haskell
show 1.2 = "1.2"
```

В даному випадку, оскільки ми працюємо з числами типу `Double`, тип функції `show` такий:

```haskell
show :: Double -> String
```

Підставимо в сигнатуру функції `map`:

```haskell
map :: (a -> b)           -> [a]      -> [b]
       (Double -> String)    [Double]    [String]

        ______                ______

                  ======                  ======
```

Саме так, як у нас і є:

```haskell
show map [1.2, 1,4, 1.6] = ["1.2","1.0","4.0","1.6"]
```

Функція `map` застосовує функцію `show` до чисел з першого списку, на виході отримуємо другий список, вже з рядками. Як і у випадку з `toUpper` функція `show` нічого не підозрює про те, що нею оперували в якості аргументу функції `map`.

Зрозуміло, в якості аргументу функції `map` ми можемо використовувати наші власні функції:

```haskell
ten :: [Double] -> [Double]
ten = map (\n -> n * 10)

main :: IO ()
main = print . ten $ [1.2, 1,4, 1.6]
```

Результат роботи:

```bash
[12.0,10.0,40.0,16.0]
```

Ми передали функції `map` нашу власну ЛФ, яка множить свій єдиний аргумент на `10`. Зверніть увагу, ми знову використовували коротку форму визначення функції `ten`, опустивши ім'я аргументу. Розкриємо детальніше:

```haskell
main = print .         ten $ [1.2, 1,4, 1.6] =
                 _____/  \_____
                /              \
               /                \
main = print . map (\n -> n * 10) $ [1.2, 1,4, 1.6]
```

Ви запитаєте, як же вийшло, що оператор застосування розташований між двома аргументами функції `map`? Хіба він не призначений для застосування функції до єдиного аргументу? Абсолютно вірно. Прийшов час відкрити ще один секрет Haskell.

## Часткове застосування

Функція `map` очікує на два аргументи, це відображено в її типі. Але що буде, якщо застосувати її не до двох аргументів, а лише до одного? В цьому випадку відбудеться ще одне &laquo;магічне&raquo; перетворення, яке називається частковим застосуванням (англ. partial application) функції. Частковим називають таке застосування, коли аргументів менше ніж очікується.

Згадаймо скорочене визначення функції `ten`:

```haskell
ten = map (\n -> n * 10)

          перший         а де ж
          аргумент       другий??
          є
```

Функція `map` отримала лише перший аргумент, а де ж другий? Другий, як ми вже знаємо, вона одержить вже потім, після того, як ми підставимо цей вираз на місце функції `ten`. Але що ж відбувається з функцією `map` до цього? А до цього з нею відбувається часткове застосування. Зрозуміло, що вона ще не може виконати свою роботу, тому, будучи застосованою лише до одного аргументу, вона повертає ЛФ! Зіставимо з типом функції `map`, і все стане на свої місця:

```haskell
map :: (a -> b) -> [a] ->          [b]

map (\n -> n * 10)

    тільки перший
    аргумент

|    частково    |
|   застосована  |
|______ map _____| аргумент        відповідь
                   частково
                   застосованої
                   функції map

                   [1.2, 1,4, 1.6]
```

Тип ЛФ, поверненої після застосування `map` до першого аргументу &mdash; `[a] -> [b]`. Це &laquo;типовий хвіст&raquo;, що залишився від повного типу функції `map`:

```haskell
map :: (a -> b) -> [a]  ->  [b]

        голова     |_ хвіст __|
```

Оскільки голова у вигляді першого аргументу типу `(a -> b)` вже є, залишилося отримати другий аргумент. Тому ЛФ, породжена частковим застосуванням, очікує єдиний аргумент, яким і буде той самий другий, а саме список`[1.2, 1,4, 1.6]`.

Зіставимо тип функції `ten` з типом `map`, щоб зрозуміти, де наш хвіст:

```haskell
ten ::             [Double] -> [Double]

map :: (a -> b) -> [a]      -> [b]

        голова     |_____ хвіст ______|
```

Ось чому ми можемо використовувати коротку форму для визначення функції `ten`: вона вже є нашим хвостом!

Розглянемо ще один приклад часткового застосування, щоб закріпити наше розуміння:

```haskell
replace :: String -> String -> String -> String
```

Це оголошення функції `replace`, яка приймає три рядки: перша містить те, що шукаємо, друга містить те, на що замінюємо, а в третій лежить те, де шукаємо. Наприклад:

```haskell
replace "http"
        "https"
        "http://google.com" = "https://google.com"
```

Визначення функції `replace` нас зараз не цікавить, розглянемо покрокове застосування:

```haskell
main :: IO ()
main = result putStrLn
  where
    first = replace "http"
    second = first "https"
    result = second "http://google.com"
```

Тип виразу `first` &mdash; `String -> String -> String`, він став результатом часткового застосування функції `replace` до першого аргументу, рядка `"http"`. Тип виразу `second` &mdash; `String -> String`, він став результатом вторинного часткового застосування функції `first` до другого аргументу, рядка `"https"`. І нарешті, застосувавши функцію `second` до третього аргументу, рядка `"http://google.com"`, ми нарешті отримуємо кінцевий результат, асоційований з виразом `result`.

З цього ми робимо цікаве відкриття:

> Функція від декількох аргументів може бути розкладена на послідовність застосувань тимчасових функцій від одного аргументу кожна.

Тому ми і змогли підставити частково застосовану `map` на місце виразу `ten`. Використовуємо круглі дужки, щоб ясніше показати, що є що:

```haskell
main = print . (map (\n -> n * 10)) $ [1.2, 1,4, 1.6]

               | частково         |
               | застосована map  |

       |      композиція функції  |
       |      print і частково    |
       |_____ застосованої map ___|
                                      аргумент для
                                      композиції
```

Гнучко, чи не так? Тепер ми знайомі з частковим застосуванням функції.

## Композиція для відображення

Повернемося до функції `map`. Якщо ми можемо передати їй якусь функцію для роботи з елементами списку, значить ми можемо передати їй і композицію двох або більше функцій. Наприклад:

```haskell
import Data.Char

pretty :: [String] -> [String]
pretty = map (stars . big)
  where
    big = map toUpper
    stars = \s -> "* "++ s ++ " *"

main :: IO ()
main = print . pretty $ ["haskell", "lisp", "coq"]
```

Ми хочемо прикрасити імена трьох мов програмування. Для цього ми пробігаємося по списку композицією двох функцій, `big` і `stars`. Функція `big` переводить терміни у верхній регістр, а функція `stars` прикрашає ім'я двома зірочками на початку і в кінці. В результаті маємо:

```bash
["* HASKELL *","* LISP *","* COQ *"]
```

Пройтися по списку композицією `stars . big` рівнозначно тому, якби ми пройшлися спочатку функцією `big`, а потім функцією `stars`. При цьому, як ми вже знаємо, обидві ці функції нічого не знають ні про те, що їх скомпонували, ні про те, що цю композицію передали функції `map`.

Ну що ж, тепер ми знаємо про функції `map`, і в наступних розділах ми побачимо безліч інших ФВП. Відтепер вони будуть нашими постійними супутниками.
