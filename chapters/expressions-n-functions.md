# Мир выражений и функций

Итак, проект создали, с пакетами познакомились, теперь мы готовы начать путешествие. Ремни пристёгивать необязательно, мы будем двигаться не торопясь.

Первой важной особенностью Haskell является тот факт, что программа - это мир выражений (англ. expression). Когда вы смотрите на исходный код, сколь бы простым или сложным он ни был - вы видите не совокупность инструкций, а совокупность выражений. Вот примеры:

```haskell
1 + 2

(12.3 - 12.067) * 456 * 0.234

length myList

"/usr" </> pathToLib

9
```

Всё это - выражения. И даже то, что вы видите на последней строке - это не просто число `9`, это тоже выражение.

Любое выражение может дать нам некий полезный результат, в противном случае оно бессмысленно. Все выражения можно разделить на две группы: такие, которые ещё можно вычислить (англ. evaluate), и такие, вычислить которые уже нельзя. Например, выражение:

```haskell
1 + 2
```

можно вычислить, то есть произвести сложение. Однако когда мы получим результирующее выражение, а именно:

```haskell
3
```

его уже нельзя вычислить, оно вычислено окончательно, что называется, до самого дна.

Когда мы вычисляем выражение, оно всегда уменьшается (англ. reduce). И уменьшать его мы можем до тех пор, пока оно не достигнет своей простейшей, окончательной формы. Например, выражение:

```haskell
(12.3 - 12.067) * 456 * 0.234
```

вычисляется в три шага:

```haskell
   (12.3 - 12.067) * 456 * 0.234
-> 0.233           * 456 * 0.234
-> 106.248               * 0.234
-> 24.862
```

Всё, дошли до дна, ничего более сделать с выражением `24.862` мы уже не способны, мы можем лишь использовать его как оно есть. Таким образом, выражения, составляющие Haskell-программу, вычисляются до тех пор, пока не останется некое окончательное, корневое выражение. Следовательно, запуск Haskell-программы на выполнение (англ. execution) - это запуск всей этой цепочки вычислений, а с корнем этой цепочки мы уже познакомились ранее. Помните функцию `main`, определённую в модуле `app/Main.hs`? Вот эта функция и является главной точкой нашей программы.

## Госпожа Функция

Именно функция делает выражение вычислимым, именно она оживляет нашу программу, потому я и назвал Функцию Первым Китом, на котором зиждется Haskell. Но дабы избежать недоразумений, следует определиться с понятиями.

Для начала вспомним математическое определение функции. Не пугайтесь, математики будет совсем немного:

> Функция - это закон, описывающий зависимость одного значения от другого.

Рассмотрим функцию возведения целого числа в квадрат:


```haskell
square v = v * v
```

Функция `square` определяет простую зависимость: числу `2` соответствует число `4`, числу `3` - `9` и так далее. Это можно записать так:

```haskell
square 2 = 4
square 3 = 9
square 4 = 16
```

Входное значение функции называют аргументом. И так как функция определяет однозначную зависимость выходного значения от аргумента, её, функцию, называют иногда *отображением*: она отображает/проецирует входное значение на выходное. Получается как бы труба: кинули в неё `2` - с другой стороны вылетело `4`, кинули `5` - ничего кроме `25` быть не может.

Чтобы заставить функцию сделать полезную работу, её нужно применить (англ. apply) к некоторому аргументу. Ведь если на вход ничего не кинули, то и на выходе ничего не получим. Вот пример:

```haskell
square 2
```

Здесь мы применили функцию `square` к значению/аргументу `2`. Синтаксис предельно прост: имя функции и через пробел - аргумент. Если же аргументов более одного - просто дописываем их через пробел. Например, функция `sum`, вычисляющая сумму двух своих целочисленных аргументов, применяется так:

```haskell
sum 10 20
```

Вы спросите, к чему я всё это рассказываю? Взгляните на применение функции `square` ещё раз. Да ведь это же выражение! То самое выражение, о котором мы узнали в самом начале главы. Вспомним:

```haskell
1 + 2
```

Это ни что иное, как применение функции. И чтобы яснее это увидеть, перепишем выражение так:

```haskell
(+) 1 2
```

Это применение функции `(+)` к двум аргументам, `1` и `2`. Теперь вы знаете: вычислить выражение - значит применить какие-то функции к каким-то аргументам.

## &laquo;Да, но разве функции не вызывают?&raquo;

В Haskell - нет. Понятие &laquo;вызов&raquo; функции пришло к нам из почтенного языка C. Там функции действительно вызывают (англ. call), потому что в языке C, в отличие от Haskell, понятие &laquo;функция&raquo; не имеет никакого отношения к математике. Там это подпрограмма, обособленный кусочек программы, доступный по некоторому адресу в памяти. Так вот если вы обладаете опытом разработки на C-подобных языках - забудьте о подпрограмме. В Haskell функция - это функция в математическом смысле этого слова. Поэтому её не вызывают, а применяют к чему-то.

А теперь отложим в сторону математику и вернёмся к программированию. Перед тем, как использовать функцию, её следует объявить и определить. Вот как это выглядит на примере `square`:

```haskell
square :: Int -> Int
square v = v * v
```

Здесь первая строка - это объявление функции, а вторая - её определение.

## Объявляем

Схема объявления следующая:

```haskell
square      :: Int           -> Int
имя функции    Тип аргумента    Тип вычисленного значения
```

Можно было бы сказать &laquo;тип возвращённого значения&raquo;, но поскольку в Haskell функции не вызывают, из них и не возвращаются. Чуть позже я поясню это.

Итак, на входе у функции `square` - единственный аргумент типа `Int` (стандартный тип в Haskell для обычных целых чисел), а на выходе - значение того же типа `Int`. Если же аргументов более одного, объявление просто вытягивается. Например, объявление упомянутой выше функции `sum` выглядит так:

```haskell
sum :: Int -> Int -> Int
```

Схема объявления вытянулась, но суть осталась прежней:

```haskell
sum         :: Int             -> Int             -> Int
имя функции    Тип 1 аргумента    Тип 2 аргумента    Тип вычисленного значения
```

Идею вы поняли: ищем крайнюю правую стрелку, и всё что левее от неё - то типы аргументов, а всё что правее - то тип вычисленного значения.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Строго говоря, объявлять функцию необязательно, мы могли бы этого и не делать (и скоро я объясню, почему). Однако возьмите за правило всегда писать объявление, это сделает ваш код значительно более понятным и легко сопровождаемым.
</span></div>

Теперь рассмотрим определение функции.

## Определяем

Вспомним определение функции `square`:

```haskell
square v = v * v
```

Схема определения такова:

```haskell
square       v              =    v * v
имя функции  имя аргумента  это  выражение
```

А функция `sum` определена так:

```haskell
sum          x                y                =    x + y
имя функции  имя 1 аргумента  имя 2 аргумента  это  выражение
```

Определение разделено на две части: слева от знака равенства - имя функции и имена аргументов (уже имена, а не типы), разделённые пробелами, а справа - выражение, составляющее суть функции, её содержимое. В языках семейства C закрепилось понятие &laquo;тело функции&raquo; (англ. function body), однако в Haskell говорят о выражении.

Обратите внимание, речь здесь идёт именно о знаке равенства, а никак не об операторе присваивания. Мы ничего не присваиваем, мы лишь декларируем равенство левой и правой частей. Когда мы пишем:

```haskell
sum x y = x + y
```

тем самым мы декларуем следующее: &laquo;Отныне выражение `sum 10 20` равно выражению `10 + 20`&raquo;. То есть везде, где написано `sum 10 20`, мы можем совершенно спокойно подставить `10 + 20`, и работа программы гарантированно останется прежней.

А впрочем, откуда у меня такая уверенность? Ответ ищите в следующей главе, и приготовьтесь к удивлению.

