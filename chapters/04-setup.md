# Приготуймося

Ми не можемо почати вивчення мови без випробувального полігону. Встановимо Haskell.

Зробити це можна кількома способами, ми виберемо найбільш зручний. Називається він [The Haskell Tool Stack](http://haskellstack.org/). Ця маленька утиліта &mdash; все, що вам знадобиться для роботи з Haskell.

Haskell &mdash; багатоплатформова мова, працює і в OS X і Linux, і навіть в Windows. Однак у 2008 році я назавжди покинув світ Windows, тому всі наступні приклади взаємодії з командним рядком мають на увазі Unix-way. Строго кажучи, я вже і забув, що таке командний рядок в Windows.

Вся конфігурація та приклади коду випробувані мною на OS X Yosemite.

## Встановлюємо

Йдемо [сюди](http://docs.haskellstack.org/en/stable/install_and_upgrade.html) і викачуємо архів для потрібної нам ОС. Розпаковуємо архів і бачимо програмку під назвою `stack`. Для зручності зберігаємо її в якомусь каталозі, доступному в `PATH`. Рекомендований шлях &mdash; `~/.local/bin/`.

Якщо ж ви живете в світі Mac і користуєтеся [Homebrew](http://brew.sh/), вам ще простіше. Робите:

``bash
$ brew update
$ brew install haskell-stack
``

Все.

На момент написання книги я використовував `stack` версії 1.0.2. Якщо у вас стара версія &mdash; неодмінно оновіть систему. Якщо ж більш нова &mdash; у вас теоретично щось може працювати не точно так, як описано нижче, оскільки `stack` активно розвивається.

Головне (але не єдине), що вміє робити `stack`, це:

1. Розгортати інфраструктуру.
2. Збирати проекти.
3. Встановлювати бібліотеки.

Haskell-інфраструктура &mdash; екосистема, наріжним каменем якої є раніше згаданий компілятор GHC. Haskell є компильованою мовою: додаток являє собою звичайний виконуваний (англ. executable) файл.

Haskell-проект &mdash; середовище для створення додатків і бібліотек.

Haskell-бібліотеки &mdash; кимось написані рішення, які рятують нас від винаходу велосипеда.

## Розгортаємо інфраструктуру

Робимо:

``bash
$ stack setup
``

В результаті на ваш комп'ютер буде встановлена інфраструктура останньої стабільної версії. Жити все це господарство буде у тільки що створеному каталозі `~/.stack/`. Саме тому встановлювати інфраструктуру для наступних Haskell-проектів вам вже не доведеться: одноразово розгорнули, використовуємо завжди. Поки вам не потрібно знати про устрій цієї інфраструктури, сприймайте її як дане: тепер на вашому комп'ютері живе Haskell.

## Hi World

Створимо наш перший Haskell-проект:

``bash
$ stack new real
``

Тут `real` &mdash; назва проекту. В результаті буде створено каталог `real`, всередині якого ми побачимо це:

``bash
.
├── LICENSE
├── Setup.hs
├── app
│ └── Main.hs <- Головний модуль
├── real.cabal <- Збірочний файл проекту
├── src
│ └── Lib.hs <- Допоміжний модуль
├── stack.yaml
└── test
└── Spec.hs
``

Про вміст проекту вам знати не потрібно, просто зберемо його командою:

``bash
$ stack install
``

Запам'ятайте цю команду, ми будемо використовувати її постійно. У результаті з'явиться файл `real-exe`. А оскільки він буде скопійований у згаданий вище каталог `~/.local/bin/`, ми зможемо відразу запустити програму:

``bash
$ real-exe
someFunc
``

Ось ми і створили Haskell-проект і запустили нашу першу програму, що вивела рядок `someFunc`. Але як же це працює? Прийшла пора познайомитися з фундаментальною одиницею проекту &mdash; модулем.

## Модулі: знайомство

Haskell-проект складається з модулів. Модулем називається файл, який містить вихідний Haskell-код. Один файл &mdash; один модуль. Розширення `.hs` &mdash; стандартне розширення для модулів. В Haskell немає поняття &laquo;файлу заголовку&raquo;: кожен з модулів розглядається як самостійна одиниця проекту, що містить у собі різні корисні речі. А щоб скористатися цими речами, необхідно один модуль імпортувати в інший.

Відкриємо модуль `src/Lib.hs`:

``haskell
module Lib -- Ім'я модуля
( someFunc
) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"
``

У першому рядку оголошено, що ім'я цього модуля &mdash; `Lib`. Далі у круглих дужках згадано вміст даного модуля, а саме ім'я функції `someFunc`. Потім, після ключового слова `where`, ми бачимо визначення функції `someFunc`. Поки вам не потрібно знати про синтаксис цієї конструкції, у наступних розділах ми розберемо його детальніше.

Тепер відкриємо модуль `app/Main.hs`:

``haskell
module Main where

import Lib -- Імпортуємо модуль Lib...

main :: IO ()
main = someFunc -- Використовуємо його вміст...
``

Це модуль `Main`, головний модуль нашого додатка, адже саме тут визначена функція `main`. За допомогою директиви `import` ми включаємо сюди модуль `Lib` і можемо працювати з вмістом цього модуля.

Запам'ятайте модуль `Main`, з ним ми будемо працювати найчастіше. Всі приклади вихідного коду, які ви побачите на сторінках цієї книги, живуть саме в модулі `Main`, якщо не обумовлено інше.

Всі модулі в наших проектах можна розділити на дві частини: ті, які ми беремо з бібліотек і ті, які ми створили самі. Бібліотеки &mdash; це вже кимось написані рішення, в наступних розділах ми познайомимося з багатьма із них. Серед бібліотек слід виділити одну, так звану стандартну бібліотеку. Модулі із стандартної бібліотеки ми почнемо використовувати вже в наступних розділах. А один з розділів буде повністю присвячений розповіді про бібліотеки: з нього ми детально дізнаємося, звідки беруться бібліотеки і як їх можна використовувати.

## Для допитливих

До появи `stack` основним способом установки Haskell була так звана [Haskell Platform](https://www.haskell.org/platform/). Однак саме `stack`, незважаючи на свою молодість (вийшов в світ влітку 2015 року), є найкращим шляхом у світ Haskell, особливо для новачків. Якщо раптом так сталося, що до моменту прочитання цього розділу у вас вже була встановлена Haskell Platform &mdash; конче рекомендую вам негайно видалити цей мотлох. Якщо у вас OS X, ви можете скористатися ось цим [маленьким скриптом](https://gist.github.com/denisshevchenko/9e8ba45fdaa4e4e8cd04).

Як ви помітили, імена файлів з вихідним кодом починаються з великої букви: `app/Main.hs` і `src/Lib.hs`. Строго кажучи, це необов'язково, можна і з маленької букви, однак для гармонії з іменем модуля краще дотримуватися загальноприйнятої практики і називати файл модуля по імені самого модуля:

``haskell
app/Main.hs -> module Main ...
src/Lib.hs -> module Lib ...
``
