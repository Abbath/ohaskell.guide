# Вибір і зразки

Цей розділ відкриє нам інші способи вибору, а також познайомить нас зі зразками. Запевняю, ви закохаєтесь в них!

## Не тільки з двох

Часто ми хочемо вибирати не тільки з двох можливих варіантів. Ось як це можна зробити:

```haskell
analizeGold :: Int -> String
analizeGold standard =
  if standard == 999
    then "Wow! 999 standard!"
    else if standard == 750
      then "Great! 750 standard."
      else if standard == 585
        then "Not bad! 585 standard."
        else "I don't know such a standard..."

main :: IO ()main = putStrLn (analizeGold 999)
```

Впевнений, що ви вже стираєте плювок з екрану. Вкладена `if-then-else` конструкція не може нікому сподобатися, адже вона вкрай незручна в зверненні. А якщо аналізованих проб золота було б штук п'ять або сім, ця драбина стала б справді жахливою. На щастя, в Haskell можна написати по-іншому:

```haskell
analizeGold :: Int -> String
analizeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard." 
     | otherwise -> "I don't know such a standard..."
```

Так красивіше, чи не так? Це &mdash; множинний `if`. Працює він за схемою:

```haskell
if | CONDITION1 -> EXPR1
   | CONDITION2 -> EXPR2
   | ...
   | CONDITIONn -> EXPRn
   | otherwise -> COMMON_EXPRESSION
```

де `CONDITION1..n` &mdash; вирази, що дають хибу або істину, а `EXPR1..n` &mdash; відповідні їм результуючі вирази. Особлива функція `otherwise` відповідає загальному випадку, коли жоден з логічних виразів не дав `True`, і в цій ситуації результатом умовної конструкції стане вираз `COMMON_EXPRESSION`.

Не нехтуйте `otherwise`! Якщо ви його не вкажете і при цьому застосуйте функцію `analizeGold` до значення, відмінного від перевірених:

```haskell
analizeGold :: Int -> String
analizeGold standard =
  if | standard == 999 -> "Wow! 999 standard!" 
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."

main :: IO ()
main = putStrLn (analizeGold 583) -- Ой...
```

компіляція завершиться успішно, однак у момент запуску програми на вас чекає неприємний сюрприз у вигляді помилки:

```bash
Non-exhaustive guards in multi-way if
```

Перевірка вийшла неповною, от і отримаєте помилку. До речі, бачите слово `guards` в повідомленні про помилку? Вертикальні риски перед логічними виразами &mdash; це і є охоронці (англ. guard), які постійно охороняють наші умови. Дотепну назву вибрали. Щоб читати їх було легше, сприймайте їх як аналог слова &laquo;АБО&raquo;.

А зараз стоп. Адже ви спробували зібрати цей код, чи не так? А чому ви не лаєтеся? Адже такий код не зкомпілюється, так як не вистачає однієї маленької, але важливої деталі. Ось як має виглядати модуль `Main`:

```haskell
{-# LANGUAGE MultiWayIf #-} -- Що це??

module Main whereanalizeGold :: Int -> String
analizeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."
     | otherwise -> "I don't know such a standard..."

main :: IO ()
main = putStrLn (analizeGold 999)
```

Ось тепер все гаразд. Але що це за дивний коментар у першому рядку модуля? Начебто оформлений як багаторядковий коментар, але виглядає незвично. Перед нами &mdash; вказівка розширення мови Haskell. Стандарт [Haskell 2010](https://www.haskell.org/onlinereport/haskell2010/) &mdash; це офіційний стрижень мови. Однак компілятор GHC, давно вже став компілятором за замовчуванням при розробці на Haskell та володіє рядом особливих можливостей. За замовчуванням багато які з цих можливостей вимкнені, а прагма `LANGUAGE` якраз для того і призначена, щоб їх вмикати/активізувати. В даному випадку ми увімкнули розширення `MultiWayIf`. Саме це розширення дозволяє нам використовувати множинний `if`. Такого роду розширень існує дуже багато, і ми будемо часто використовувати. Пам'ятайте: розширення, включене з допомогою прагми `LANGUAGE`, діє лише в рамках поточного модуля. І якщо я прописав його тільки в модулі `app/Main.hs`, то на модуль `src/Lib.hs` механізм `MultiWayIf` не поширюється.

## Без Якщо

Множинний `if` досить зручний, але є спосіб більш красивий. Погляньте:

```haskell
analizeGold :: Int -> String
analizeGold standard
  | standard == 999 = "Wow! 999 standard!"
  | standard == 750 = "Great! 750 standard."
  | standard == 585 = "Not bad! 585 standard."
  | otherwise = "I don't know such a standard..."
```

Ключове слово `if` зникло. Схема тут така:

```haskell
function arg -- Немає знаку рівності?
  | CONDITION1 = EXPR1
  | CONDITION2 = EXPR2
  | ...
  | CONDITIONn = EXPRn
  | otherwise  = COMMON_EXPRESSION
```

Будова майже така ж, але, крім зникнення ключового слова `if`, ми тепер використовуємо знаки рівності замість стрілок. Саме тому зник знайомий нам знак рівності після імені аргументу `arg`. Насправді він, звісно, нікуди не зник, він лише перейшов в вирази. А щоб це легше прочитати, запишемо вирази в рядок:

```haskell
function arg |   CONDITION1 =         EXPR1  | ...

ця                    або            дорівнює
функція                                        цьому
                                               виразу
                          у разі
                          істинності
                          цього
                          виразу
                                                      або і т. д.
```

Тобто перед нами вже не одне визначення функції, а ланцюжок визначень, тому нам і не потрібно ключове слово `if`. Але і цей ланцюжок визначень можна спростити.

## Порівняння зі зразком

Прибравши слово `if`, і ми з нашими віртуальними &laquo;АБО&raquo; можемо розлучитися. В цьому випадку залишиться лише це:

```haskell
analizeGold :: Int -> String -- Одне оголошення.
-- Та безліч визначень...
analizeGold 999 = "Wow! 999 standard!"
analizeGold 750 = "Great! 750 standard."
analizeGold 585 = "Not bad! 585 standard."
analizeGold _ = "I don't know such a standard..."
```

Ми просто перерахували визначення функції `analizeGold` одне за іншим. На перший погляд, можливість безлічі визначень однієї і тієї ж функції дивує, але якщо згадати, що застосування функції суть вираз, тоді нічого дивного. Ось як це читається:

```haskell
     analizeGold 999            =        "Wow! 999 standard!"

якщо ця функція  застосовується тоді     цьому виразу
                 до цього       вона
                 аргументу      дорівнює

     analizeGold 750            =        "Wow! 999 standard!"

якщо ця функція  застосовується тоді     іншому виразу
                 до іншого      вона
                 аргументу      дорівнює
...
          analizeGold _ =       "I don't know such a standard..."
в
іншому    ця функція   просто   деякому загальному виразу
ж випадку              дорівнює
```

Коли функція `analizeGold` застосовується до конкретного аргументу, цей аргумент послідовно порівнюється із зразком (англ. pattern matching). Зразка тут три: `999`, `750` і `585`. І якщо раніше ми порівнювали аргумент з цими числовими значеннями явно, за допомогою функції `==`, тепер це відбувається приховано. Ідея порівняння із зразком дуже проста: щось (в даному випадку реальний аргумент) зіставляється із зразком (або зразками) на предмет &laquo;підходить/не підходить&raquo;. Якщо підходить &mdash; тобто порівняння із зразком дає результат `True` &mdash;готово, використовуємо відповідний вираз. Якщо ж не підходить &mdash; переходимо до наступного зразка.

Порівняння із зразком використовується в Haskell надзвичайно широко. У україномовній літературі переклад словосполучення &laquo;pattern matching&raquo; не особливо закріпився, замість цього так і кажуть &laquo;патерн матчінг&raquo;. Я зроблю так само.

Але що це за символ підкреслення такий, в останньому варіанті визначення? Ось цей:

```haskell
analizeGold _ = "I don't know such a standard..."
```

З формальної точки зору, це &mdash; універсальний зразок, порівняння з яким завжди істинно (ще говорять, що з ним матчиться (англ. match) все що завгодно). А з неформальної &mdash; це символ, який можна прочитати, як &laquo;мені все одно&raquo;. Ми неначе кажемо: &laquo;У даному разі нас не цікавить конкретний вміст аргументу, нам все одно, ми просто повертаємо рядок `I don't know such a standard...`&raquo;.

Важливо відзначити, що порівняння аргументу із зразками відбувається послідовно, згори вниз. Тому якщо ми напишемо так:

```haskell
analizeGold :: Int -> String
analizeGold _ = "I don't know such a standard..."
analizeGold 999 = "Wow! 999 standard!"
analizeGold 750 = "Great! 750 standard."
analizeGold 585 = "Not bad! 585 standard."
```

наша функція буде завжди повертати перший вираз, рядок `I don't know such a standard...`, і це цілком очікувано: перша ж перевірка гарантовано дасть нам `True`, адже з зразком `_` збігається все що завгодно. Таким чином, загальний зразок слід розташовувати в самому кінці, щоб ми потрапили на нього лише після того, як не спрацювали всі інші зразки.

## case

Існує ще один вид патерн матчінгу, за допомогою конструкції `case-of`:

```haskell
analizeGold standard =
  case standard of
    999 -> "Wow! 999 standard!"
    750 -> "Great! 750 standard."
    585 -> "Not bad! 585 standard."
    otherwise -> "I don't know such a standard..."
```

Запам'ятайте конструкцію `case-of`, ми зустрінемося з нею не раз. Працює вона згідно моделі:

```haskell
case ВИРАЗ of
  PATTERN1 -> EXPR1
  PATTERN2 -> EXPR2
  ...
  PATTERNn -> EXPRn
  otherwise -> COMMON_EXPRESSION
```

де `EXPRESSION` &mdash; аналізований вираз, послідовно порівнюється із зразками `PATTERN1..n`. Якщо жоден не спрацював &mdash; як звичайно, впираємося в `otherwise` і видаємо `COMMON_EXPRESSION`.

У наступних розділах ми зустрінемося і з іншими видами патерн матчінгу, адже він використовується не лише для вибору.
