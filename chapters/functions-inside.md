# Функции внутри

В предыдущей главе я одним махом открыл вам много нового. Пришло время разбираться более детально. В этой главе рассмотрим содержимое функций. Ведь раз уж Haskell-программа состоит из выражений, а те, в свою очередь, представляют собой применение неких функций к неким аргументам, то можно сказать, что всё, происходящее внутри программы, происходит внутри функций. Именно поэтому содержимое функций представляет для нас исключительный интерес.

В прошлой главе мы увидели простейшие функции, такие как `sum`:

```haskell
sum :: Int -> Int -> Int
sum x y = x + y
```

Вот её содержимое:

```haskell
x + y
```

Согласитесь, не очень интересно. Да, нужны и такие, но в реальных программах нужны штуки помощнее. Но прежде чем погрузиться в функции, познакомимся с некоторыми простейшими типами в Haskell, без них нам не обойтись.

С типом `Int` вы уже знакомы, значения этого типа содержат обыкновенные целые числа. Тип `Double` предназначен для чисел с плавающей точкой. Значения типа `Char` - это Unicode-символы. Значение типа `String` - обычная строка. Значение типа `Bool` отражает истину (`True`) или ложь (`False`). Вот примеры:

```haskell
123                  -- Int

2.0678               -- Double

'A'                  -- Char

"Hello, Haskeller!"  -- String

True                 -- Bool, который истина

False                -- Bool, который ложь
```

Пока достаточно. В Haskell есть ещё несколько важных стандартных типов, но о них узнаем чуть позже. И кстати, вы уже второй раз видите конструкцию, состоящую из двух минусов `--`. Это - начало однострочного комментария. А между символами `{-` и `-}` живёт многострочный комментарий:

```haskell
-- Я - однострочный комментарий, живу в единственной строке

{-
   А я - многострочный
   комментарий, содержащий нечто
   прелюбопытнейшее!
-}
```

Ну а теперь прыгнем в функции.

## Условие

Так выглядит условная конструкция:

```haskell
if CONDITION then EXPRESSION1 else EXPRESSION2
```

где `CONDITION` - выражение, дающее ложь или истину, `EXPRESSION1` - выражение, используемое в случае `True`, `EXPRESSION2` - выражение, используемое в случае `False`. Пример:

```haskell
checkLocalhost :: String -> String
checkLocalhost ip =
    if ip == "127.0.0.1" || ip == "0.0.0.0" || ip == "::1"
        then "It's a localhost!"
        else "No, it's not a localhost."
```

Функция `checkLocalhost` применяется к единственному аргументу типа `String` и возвращает/вычисляет другое значение типа `String`. В качестве аргумента выступает строка, содержащая IP-адрес, а функция проверяет, не лежит ли в ней localhost. Оператор `||` - стандартый оператор логического &laquo;ИЛИ&raquo;, а оператор `==` - стандартный оператор проверки на равенство.

Теперь откроем наш модуль `app/Main.hs`, найдём функцию `main` и напишем следующее:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "127.0.0.1")
```

Вспоминаем команду сборки, которую мы запускаем, находясь в корне нашего проекта:

```bash
$ stack install
```

После сборки запускаем:

```bash
$ real-exe
It's a localhost!
```

А если перепишем так:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.222.100")
```

тогда при запуске увидим это:

```bash
No, it's not a localhost.
```

Функция `putStrLn` - это стандартная функция, выводящая на консоль некую строку. В данном случае она вывела строку, возвращённую функцией `checkLocalhost`.























## Возврат из функции

В императивных языках, подобных C, существует особая инструкция `return`, предназначенная для явного возврата значения из функции. Поскольку функции там - это подпрограммы, наличие такой инструкции необходимо потому, что точек выхода/возврата из функции может быть несколько. Например, на C++ функция `checkLocalhost` могла бы выглядеть так:

```cpp
std::string checkLocalhost(const std::string& ip) {
    if(ip == "127.0.0.1" || ip == "0.0.0.0" || ip == "::1") {
        return "It's a localhost!";     // Выходим здесь...
    }

    return "No, it's not a localhost."  // ... или здесь.
}
```

В Haskell не существует аналога инструкции `return`, поскольку единственной &laquo;точкой возврата&raquo; из функции является её конечный результат. Звучит необычно, поясню примером.

Как мы знаем, применение функции - это выражение. А так как оперирует оно с неизменными данными, мы всегда можем заменить выражение своим конечным результатом. И ничего не сломается. Например, выражение:

```haskell
checkLocalhost "127.0.0.1"
```

может быть заменено

