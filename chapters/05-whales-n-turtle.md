# Кити і Черепаха

Отже, проект створили, тепер ми готові розпочати нашу подорож.

Haskell стоїть на Трьох Китах, імена яких: **Функція**, **Тип** ** і * Клас типів**. Вони ж, у свою чергу, спочивають на величезній Черепасі, ім'я якої &nbsp; **Вираз**.

## Черепаха

Haskell-програма є сукупністю виразів (англ. expression). Погляньте:

``haskell
1 + 2
``

Це &mdash; основна цеглина Haskell-програми, будь то Hello World або частина інфраструктури міжнародного банку. Звичайно, крім додавання одиниці з двійкою існують і інші вирази, але суть у них у всіх одна:

> Вираз &mdash; це те, що може дати нам певний корисний результат.

Всі вирази можна розділити на дві групи: ті, які (все ще) можна обчислити і ті, що (вже) не можна. Обчислення (англ. evaluation) &mdash; це фундаментальна дія по відношенню до виразу, адже саме обчислення дає нам той самий корисний результат. Так, вираз:

``haskell
1 + 2
``

може дати нам корисний результат, а саме суму двох чисел. Обчисливши вираз, ми отримуємо результат:

``haskell
3
``

Причому це не просто число `3`, це теж вираз. Подібний вираз вже не можна обчислити, він обчислений остаточно, до самого дна, і ми можемо лише використовувати його як є.

В результаті обчислення вираз завжди зменшується (англ. reduce). У україномовній літературі іноді так і пишуть: &laquo;редукція виразів&raquo;. Зменшувати вираз можна до тих пір, поки він не досягне своєї нередукованої форми. Згаданий вище вираз `1 + 2` ще можна редукувати, а от вираз `3` &mdash; вже не можна.

Таким чином, вирази, складові програми, обчислюються/редукуються до тих пір, поки не залишиться якийсь остаточний, кореневий вираз. А запуск Haskell-програми на виконання (англ. execution) &mdash; це запуск всього цього ланцюжка обчислень, причому з коренем цього ланцюжка ми вже познайомилися раніше. Пам'ятаєте функцію `main`, визначену в модулі `app/Main.hs`? Ось ця функція і є головною точкою нашої програми, її Альфою і Омегою.

## Перший Кит

Повернемося до виразу `1 + 2`. Корисний результат ми отримаємо лише після того, як обчислимо вираз, тобто здійснимо додавання. І як же можна &laquo;здійснити додавання&raquo; в рамках Haskell-програми? За допомогою функції. Саме функція робить вираз обчислюваним, саме вона оживляє нашу програму, тому я і назвав Функцію Першим Китом Haskell. Але щоб уникнути непорозумінь, визначимося з поняттями.

Згадаймо математичне визначення функції. Не лякайтеся, математики буде зовсім небагато:

> Функція &mdash; це закон, що описує залежність одного значення від іншого.

Розглянемо функцію піднесення цілого числа до квадрату:

``haskell
square v = v * v
``

Функція `square` визначає просту залежність: числу `2` відповідає число `4`, `3` &mdash; `9`, і так далі. Схематично це можна записати так:

``haskell
2 -> 4
3 -> 9
4 -> 16
5 -> 25
...
``

Вхідне значення функції називають аргументом. А так як функція визначає однозначну залежність вихідного значення від аргументу, її, функцію, називають ще *відображенням*: вона відображає/проектує вхідне значення на вихідне. Виходить неначе труба: кинули в неї `2` &mdash; з іншого боку вилетіло `4`, кинули `5` &mdash; вилетіло `25`.

Щоб змусити функцію зробити корисну роботу, її необхідно застосувати (англ. apply) до аргументу. Приклад:

``haskell
square 2
``

Ми застосували функцію `square` до аргументу `2`. Синтаксис гранично простий: ім'я функції і через пробіл аргумент. Якщо аргументів більше одного &mdash; просто дописуємо їх так само, через пробіл. Наприклад, функція `sum`, яка обчислює суму двох своїх цілочисельних аргументів, застосовується так:

``haskell
sum 10 20
``

Так от вираз `1 + 2` є ніщо інше, як застосування функції! І щоб ясніше побачити, перепишемо вираз:

``haskell
(+) 1 2
``

Це застосування функції `(+)` до двох аргументів, `1` і `2`. Не дивуйтеся, що ім'я функції вставлено в дужки, незабаром я розповім про це детальніше. А поки запам'ятайте головне:

> Обчислити вираз &mdash; це значить застосувати якісь функції (одну або більше) до якихось аргументів (одного або більше).

І ще. Можливо, ви чули про так званий &laquo;виклик&raquo; функції. В Haskell функції не викликають. Поняття &laquo;виклик&raquo; функції прийшло до нас з поважної мови C. Там функції дійсно викликають (англ. call), тому що в C, на відміну від Haskell, поняття &laquo;функція&raquo; не має ніякого відношення до математики. Там це підпрограма, тобто відокремлений шматочок програми, доступний за певною адресою в пам'яті. Якщо у вас є досвід розробки на C-подібних мовах &mdash; забудьте про підпрограми. В Haskell функція &nbsp; це функція в математичному сенсі слова, тому її не викликають, а застосовують до чогось.

## Другий Кит

Отже, будь-який редукований вираз це застосування функції до деякого аргументу (теж є виразом):

``haskell
square  2
функція аргумент
``

Аргумент являє собою деяке значення, його ще називають &laquo;даними&raquo; (англ. data). Дані в Haskell &mdash; це сутності, які володіють двома головними характеристиками: типом і конкретним змістом/вмістом.

Тип &mdash; це Другий Кит в Haskell. Тип відображає конкретний вміст даних, а тому всі дані в програмі обов'язково мають якийсь тип. Коли ми бачимо дані типу `Double`, ми точно знаємо, що перед нами число з плаваючою точкою, а коли бачимо дані `String` &mdash; можемо ручатися, що перед нами рядок.

Ставлення до типів в Haskell дуже серйозне, і робота з типами характеризується трьома важливими рисами:

1. статична перевірка,
2. сила,
3. виведення.

Ці три властивості системи типів Haskell &mdash; наші добрі друзі, адже вони роблять наше програмістське життя щасливішим. Познайомимося з ними.

### Статична перевірка

Статична перевірка типів (англ. static type checking) &mdash; це перевірка всіх типів даних в програмі, яка здійснюється на етапі компіляції. Haskell-компілятор впертий: коли йому щось не подобається в типах, він голосно лається. Тому якщо функція працює з цілими числами, застосувати її до рядків ніяк не вийде. Так що якщо компіляція нашої програми завершилася успішно, ми точно знаємо, що з типами у нас все в порядку. Переваги статичної перевірки неможливо переоцінити, адже вона гарантує відсутність в наших програмах цілого ряду помилок. Ми вже не зможемо сплутати числа з рядками або відняти метри від гривень.

Звичайно, у цієї медалі є і зворотня сторона &nbsp; час, який витрачається на компіляцію. Вам доведеться звикнутися з цією думкою: внесли зміни в проект &mdash; будьте ласкаві зкомпілювати. Однак втіхою вам нехай послужить той факт, що переваги статичної перевірки куди цінніші за час, витрачений на компіляцію.

### Сила

Сильна (англ. strong) система типів &mdash; це безкомпромісний контроль відповідності очікуваного дійсному. Сила робить роботу з типами ще більш акуратною. Ось вам приклад зі світу C:

``c
double coeff(double base) {
return base * 4.9856;
}

int main() {
int value = coeff(122.04);
...
}
``

Це канонічний приклад проблеми, обумовленої слабкою (англ. weak) системою типів. Функція `coeff` повертає значення типу `double`, однак викликаюча сторона очікує чомусь ціле число. Ну ось ми помилилися, криво зкопіювали. В цьому випадку відбудеться шахрайство, зване прихованим приведенням типів (англ. type casting): число з плаваючою крапкою, повернуте функцією `coeff`, буде брутально зламано шляхом приведення до типу `int`, в результаті чого дробова частина буде відкинута і ми отримаємо не `608.4426`, а `608`. Подібна помилка, до речі, призводила до серйозних наслідків, таких як руйнування космічних апаратів.

В Haskell подібний код не має жодних шансів пройти компіляцію. Ми завжди отримуємо те, що очікуємо, і якщо має бути число з плаваючою точкою &mdash; хоч убийся, але надай саме його. Компілятор скрупульозно відстежує відповідність очікуваного типу фактичному, тому коли компіляція завершується успішно, ми абсолютно впевнені в гармонії між типами всіх наших даних.

### Виведення

Виведення (англ. inference) типів &mdash; це здатність визначити тип даних автоматично з конкретного виразу. У тій же мові C тип даних слід вказувати явно:

``c
double value = 122.04;
``

проте в Haskell ми напишемо просто:

``haskell
value = 122.04
``

У цьому випадку компілятор автоматично виведе тип `value` як `Double`.

Виведення типів робить наш код лаконічнішим і простішим в супроводі. Втім, ми можемо вказати тип значення і явно, а іноді навіть повинні це зробити. У наступних розділах я поясню, чому.

Так, до речі, ось найпростіші стандартні типи, вони нам знадобляться:

``haskell
123 Int
23.5798 Double
'a' Char
"Hello!" String
True Bool, істина
False Bool, хиба
``

З типами `Int` і `Double` ви вже знайомі. Тип `Char` &mdash; це Unicode-символ. Тип `String` &mdash; звичайний рядок. Тип `Bool` &mdash; логічний тип, що відповідає істині або хибі. У наступних розділах ми зустрінемося ще з кількома стандартними типами, але поки вистачить і цих. І зауважте: ім'я типу в Haskell завжди починається з великої літери.

## Третій Кит

А ось про Третього Кита, про **Класи типів**, я поки промовчу, тому що знайомитися з ним слід лише після того, як ми ближче потоваришуємо з першими двома.

Впевнений, після прочитання цього розділу, з'явилося безліч запитань. Відповіді будуть, але пізніше. Більше того, наступний розділ безсумнівно здивує вас.

## Для допитливих

Якщо ви працювали з об'єктно-орієнтованими мовами, такими як C++, вас здивує той факт, що в Haskell між поняттями &laquo;тип&raquo; і &laquo;клас&raquo; проведено чітку межу. А оскільки типам і класам типів в Haskell відведена колосально важлива роль, добра вам порада: коли у майбутніх розділах ми познайомимося з ними ближче, не намагайтеся проводити аналогії з іншими мовами. Наприклад, деякі вбачають спорідненість між класами типів в Haskell і інтерфейсами в Java. Не робіть цього, щоб уникнути плутанини.
