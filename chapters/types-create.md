----
title: Типы - творим
prevChapter: /ru/---.html
nextChapter: /ru/---.html
----

В языке Haskell мало встроенных типов. Есть числа разные, символ, список и ещё чуток. Все же остальные типы, даже носящие статут стандартных, не являются встроенными, и потому компилятор ничего не знает о них. Вместо этого они определены в библиотеках, и это одна из важнейших черт Haskell: создавать новые типы здесь очень просто.

## Hello World

Определим тип `Transport` для двух распространённых протоколов транспортного уровня модели OSI:

```haskell
data Transport = TCP | UDP
```

Перед нами - предельно простой, но уже наш собственный тип. Рассмотрим его внимательнее.

Ключевое слово `data` - это начало определение типа. Далее следует название типа, в данном случае `Transport`. Запомните эту важную деталь: название любого типа в Haskell всегда начинается с большой буквы. Затем идёт знак равенства (именно равенства, а никак не присваивания), после которого начинается фактическое описание типа, его "тело". В данном случае оно состоит из двух простейших конструкторов. Конструктор значения (англ. data constructor) - это то, что строит значение данного типа. Здесь у нас два конструктора, `TCP` и `UDP`, каждый из которых строит значение типа `Transport`. И кстати, имя конструктора тоже обязано начинаться с большой буквы.

Данное определение очень легко читается:

```
data  Transport  =    TCP  |    UDP

тип   Transport  это  TCP  или  UDP
```

И теперь мы можем использовать тип `Transport`, а именно создавать соответствующие значения и что-то с ними делать. Например:

```haskell
    let protocol = TCP
```

Мы создали значение `protocol` типа `Transport`, использовав конструктор `TCP`. А можно и так:

```haskell
    let protocol = UDP
```

Хотя мы использовали разные конструкторы, тип значения `protocol` в обоих случаях - `Transport`.

Расширить такой тип предельно просто. Захотелось нам добавить SCTP (Stream Control Transmission Protocol) - пожалуйста:

```haskell
data Transport = TCP | UDP | SCTP
```

Добавили третий конструктор - появился третий способ создать значение типа `Transport`.

## Значение

А в самом деле, когда мы говорим о "значении" типа `Transport` - о каком в действительности значении идёт речь? Казалось бы, значения фактического вроде бы и нет: ни числа, ни строки, просто три конструктора. Так вот эти три конструктора и порождают собою три значения. Поэтому когда мы пишем:

```haskell
    let protocol = SCTP
```

мы создаём сущность типа `Transport` со значением `SCTP`. В данном случае значение - это и есть конструктор. Это простейший вид конструктора и называется он нульарным. Таким образом, тип `Transport` имеет три нульарных конструктора.

Однако в большинстве случаев мы желаем иметь дело со значениями поинтереснее. В этом случае нульарным конструктором мы уже не обойдёмся. Оставим сетевые протоколы, рассмотрим другой пример:

```haskell
data IPAddress = IPAddress String
```

Тип `IPAddress` использует один-единственный конструктор, но кое-что изменилось. Во-первых, имена типа и конструктора совпадают. Это вполне легально, и во многих Haskell-проектах вы часто будете видеть типы с одноимёнными конструкторами. Во-вторых, конструктор уже не нульарный, потому что имеет одно значение типа `String`. Такой конструктор называют унарным, и вот как мы будем создавать значения типа `IPAddress`:

```haskell
    let ip = IPAddress "127.0.0.1"
```

Значение `ip` наполнено уже нашим собственным строковым содержимым. С концептуальной точки зрения тип `IPAddress` теперь можно рассматривать как контейнер, внутри которого лежит наша строка, содержащая IP-адрес.

Расширим тип `IPAddress`, сделав его более современным:

```haskell
data IPAddress = IPv4 String | IPv6 String
```

Теперь у нас два конструктора, отражающие разные IP-версии. Это позволит нам создавать значение типа `IPAddress` так:

```haskell
    let ip = IPv4 "127.0.0.1"
```

или так:

```haskell
    let ip = IPv6 "2001:0db8:0000:0042:0000:8a2e:0370:7334"
```

Конечно, нульарные конструкторы можно совмещать с унарными. Вот пример использования: когда мы работаем с IP-адресом, очень часто нам требуется `localhost`. Так вот чтобы явно не писать `"127.0.0.1"` и `"0:0:0:0:0:0:0:1"`, введём ещё два конструктора:

```haskell
data IPAddress = IPv4 String | IPv4Localhost | IPv6 String | IPv6Localhost
```

Поскольку значения `localhost` стандартизованы и всегда одни и те же, нам нет нужды указывать их явно. Вместо этого, когда нам понадобится IPv4-localhost, пишем так:

```haskell
    let ip = IPv4Localhost
```

И всем сразу понятно: значение `ip` соответствует `"127.0.0.1"`.

И кстати, о стилистике. В Haskell-мире определение типа с несколькими конструкторами принято писать так:

```haskell
data IPAddress = IPv4 String
               | IPv4Localhost
               | IPv6 String
               | IPv6Localhost
```

Вертикальные черты, отражающие концептуальные "ИЛИ", выровнены вертикально и строго под знаком равенства. Нет, вы вовсе не обязаны писать так же, просто во многих Haskell-проектах вы увидите именно такое форматирование.

И да, раз уж мы видели нульарный и унарный конструкторы, логично предположить, что существуют также и бинарные, и тернарные и т.д. Так оно и есть:

```haskell
data EndPoint = EndPoint String Int
```

Тип `EndPoint` представлен единственным бинарным конструктором, принимающим два значения, строковое для IP-адреса и целочисленное для порта:

```haskell
    let googlePoint = EndPoint "173.194.122.211" 80
```

Можно сказать, что тип `EndPoint` представляет собой контейнер с двумя ячейками, строковой и целочисленной.

## Типы как кирпичи

Не кажется ли вам, что с типом `EndPoint` что-то не так? Да, из названия типа следует, что строка тут - это не просто какая-то строка, это сетевой адрес. Но откуда мы знаем, что там именно IP-адрес? А может программист напишет так:

```haskell
    let googlePoint = EndPoint "www.google.com" 80
```

Однако в ряде случаев это может быть неприемлемым решением. Выход? Так оно у нас уже есть, взгляните выше! Мы же определили тип `IPAddress`, так почему же не воспользоваться им? Переписываем:

```haskell
data EndPoint = EndPoint IPAddress Int
```

Вот, так гораздо лучше! Такой тип уже содержит в себе "документацию": теперь мы точно знаем, что создавать значения типа `EndPoint` следует именно с IP-адресом. Например:






