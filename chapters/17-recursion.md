# Рекурсія

> Щоб зрозуміти рекурсію потрібно спочатку зрозуміти рекурсію.

Цей старий жарт про рекурсію іноді лякає новачків, як у свій час налякав мене. Насправді в рекурсії немає нічого страшного, і в цьому розділі ми познайомимося з цим важливим механізмом.

## Цикл

Дивно, але в Haskell немає вбудованих циклічних конструкцій, настільки звичних для інших мов. Ні тобі `for`, ні `while`. Однак обійтися без циклів в нашому коді ми не зможемо. Як же нам їх організовувати?

На щастя, найчастіше нам це й не потрібно. Згадаймо нашу знайому, функцію `map`:

```haskell
map toUpper someList
```

Ну і чим же не цикл? На тому ж C це виглядало би так:

```c
int length = ...
for(int i = 0; i < length; ++i) {
    char result = toUpper(someList[i]);
...
}
```

Функції, на зразок `map`, в переважній більшості випадків позбавляють нас від написання явних циклічних конструкцій, і це радує. Однак зрідка нам все-таки доведеться писати цикли явно. В Haskell, через відсутність `for`-конструкції, зробити це можна тільки одним способом &mdash; через рекурсію (англ. recursion).

Ідея рекурсії дуже проста:

> Якщо нам потрібно повторити обчислення, зроблене певною функцією, ми повинні застосувати цю функцію всередині себе самої. І вийде зациклення.

Поглянемо на визначення функції `map`:

```haskell
map _ [] = []
map f (x:xs) = f x : map f xs
```

А тепер розберемо це цікаве визначення по кісточках.

## Правда списку

Першим аргументом, як ми пам'ятаємо, виступає певна функція, а другим &mdash; список, до елементів якого застосовується ця функція. Але що це за дивного вигляду конструкція в круглих дужках?

```haskell
(x:xs)
```

Це &mdash; особливий зразок, який використовується для роботи зі списками. Щоб він став зрозумілим, я повинен розповісти вам правду про формування списку.

Як ми пам'ятаємо, формується список дуже просто:

```haskell
[1, 2, 3] -- Список з трьох цілих чисел.
```

Проте насправді він формується дещо інакше. Звична нам конструкція в квадратних дужках є ніщо інше, як синтаксичний цукор (англ. syntactic sugar). Синтаксичним цукром називають якесь спрощення коду, що робить його солодшим, приємнішим для нас. Якщо ж ми приберемо цукор (або, як ще кажуть, &laquo;розцукруємо&raquo; код), то побачимо ось що:

```haskell
1 : 2 : 3 : []
```

Саме так список з трьох цілих чисел формується насправді. Стандартний оператор `:` нам вже знайомий, ми зустрілися з ним у главі про списки:

```haskell
newHost :        hosts

        цей
        оператор

бере
це
значення
                 і додає
                 його на початок
                 цього списку
```

Тобто список будується шляхом додавання елемента в його &laquo;голову&raquo;, починаючи з порожнього списку:

```haskell
1 : 2 : 3 : []

= 1 : 2 : [3]

= 1 : [2, 3]

= [1, 2, 3]
```

Починаючи з правого краю, ми спочатку застосовуємо оператор `:` до `3` і порожнього списку, в результаті чого отримуємо список з одним елементом `[3]`. Потім, застосовуючи другий оператор `:` до `2` і до щойно отриманого списку `[3]`, ми отримуємо новий список `[2, 3]`. Врешті, знову застосувавши оператор `:` до `1` і до списку `[2, 3]`, ми отримуємо підсумковий список`[1, 2, 3]`. Ось чому так зручно оперувати &laquo;головою&raquo; і &laquo;хвостом&raquo; списку. І саме тому був створений особливий зразок для патерн-матчінгової роботи зі списком:

```haskell
(head : tail)
```

У даному випадку слова `head` і `tail` не належать до стандартних функцій, я лише показую призначення елементів даного зразка. Ось живий приклад:

```haskell
main :: IO ()
main = first print
  where
    (first:others) = ["He", "Li", "Be"]

     _____              ____

           ======           ==========
```

Оскільки ми точно знаємо, що справа у нас список, зліва ми пишемо зразок списку, в якому `first` асоційований з першим елементом, з &laquo;головою&raquo;, а шаблон `others` &mdash; з рештою елементів, з &laquo;хвостом&raquo;.

Але ви запитаєте, навіщо нам це потрібно? Якщо вже ми так хочемо працювати зі списком через патерн матчінг, можна скористатися явним зразком:

```haskell
main :: IO ()
main = first print
where
[first, second, third] = ["He", "Li", "Be"]

 _____                      ____

        ======                  ====

                +++++                 ++++
```

Все вірно, однак зразок з круглими дужками надзвичайно зручний саме для рекурсивну роботи зі списком, і ось чому. Згадаймо визначення функції `map`:

```haskell
map f (x:xs) = f x : map f xs

       _         _

         ==                ==
```

Підставимо реальні значення на основі прикладу про переведення символів рядка в верхній регістр:

```haskell
map f (x:xs) = f x : map f xs

map toUpper "neon" = toUpper 'n' : map toUpper "eon"

             _                _

              ===                               ===
```

Ось тепер ми бачимо, яким чином функція `map` пробігає по всьому списку. Пройдемося по ітераціях, щоб все остаточно стало на свої місця. У нас же цикл, вірно? А де цикл &mdash; там ітерації.

На першій з них оператор `:` застосовується до виразів `toUpper 'n'` та `map toUpper "eon"`. Вираз зліва обчислюється й дає нам символ `H`:

```haskell
toUpper 'n' : map toUpper "eon"

'H'         : map toUpper "eon"
```

Вираз праворуч містить застосування тієї ж функції `map`, тобто ми входимо в цикл, у другу ітерацію:

```haskell
map toUpper "eon" = toUpper 'e' : map toUpper "on"
```

Вираз зліва обчислюється і дає нам `E`:

```haskell
toUpper 'e' : map toUpper "on"

'E'         : map toUpper "on"
```

Обчислюємо вираз праворуч &mdash; та входимо в наступну ітерацію:

```haskell
map toUpper "on" = toUpper 'o' : map toUpper "n"
```

Вираз зліва дає нам `O`:

```haskell
toUpper 'o' : map toUpper "n"

'O'         : map toUpper "n"
```

Справа знову застосування `map` &mdash; й наша остання ітерація:

```haskell
map toUpper "n" = toUpper 'n' : map toUpper []
```

Вираз зліва дає нам `N`:

```haskell
toUpper 'n' : map toUpper []

'N'         : map toUpper []
```

Ми витягнули зі списку останній з чотирьох символів, і список залишився порожнім. Що ж ми будемо робити далі? А далі ми згадуємо перший варіант визначення функції `map`:

```haskell
map _ [] = []
```

Тут функція каже: &laquo;Як тільки я другим аргументом отримаю порожній список, я, ігноруючи перший аргумент, негайно поверну той самий порожній список&raquo;. Тому вираз, який залишився на останній ітерації праворуч:

```haskell
map toUpper []
```

підійде під даний випадок і просто дасть нам порожній список. Все, готово, робота функції завершена. На кожній ітерації ми відкушуємо &laquo;голову&raquo; списку і передаємо її функції `toUpper`, &laquo;хвіст&raquo; же передаємо знову функції `map`. На четвертій ітерації зупиняємося на порожньому списку і повертаємо його. Поєднавши всі ітерації воєдино, отримуємо ось що:

```haskell
'N' : 'E' : 'O' : 'N' : []
```

Впізнаєте? Це ж наш &laquo;розцукрований&raquo; список, що з'єднується воєдино:

```haskell
['N', 'E', 'O', 'N']
```

Ось ми й прийшли до нашої рівності:

```haskell
map toUpper "neon"

= map toUpper ['n', 'e', 'o', 'n']

= ['N', 'E', 'O', 'N']

= "NEON"
```

## Туди й назад

Визначаючи рекурсивну функцію, важливо пам'ятати про те, що в ній, як правило, повинно бути як і зациклення, так і правило виходу з циклу:

```haskell
map _ [] = [] -- Виходимо з циклу.
map f (x:xs) = f x : map f xs -- Зациклюємося,
                              -- застосовуючи саму себе.
```

Якщо б ми опустили перше визначення, компілятор завбачливо повідомив би нас про проблему:

```bash
Match Pattern(es) are non-exhaustive
```

Це абсолютно правильно: якщо на кожній ітерації ми зменшуємо список, то рано чи пізно список точно залишиться порожнім, а отже, ми зобов'язані пояснити, що ж робити в цьому випадку.

## Для допитливих

Відкрию таємницю: рекурсивними в Haskell бувають не тільки функції, але й типи. Але про це в наступних розділах.
