# Кортеж

У цьому розділі ми познайомимося з кортежем і ще ближче подружимося з патерн матчінгом.

Кортеж (англ. tuple) &mdash; ще одна стандартна структура даних, але, на відміну від списку, вона може містити як дані одного типу, так і різних.

Структури, здатні містити дані різних типів, називають гетерогенними (в перекладі з грецької: &laquo;різного роду&raquo;).

Ось як виглядає кортеж:

```haskell
("Haskell", 2010)
```

Круглі дужки і значення розділені комами. Цей кортеж містить значення типу `String` і ще одне, типу `Int`. Ось ще приклад:

```haskell
("Haskell", "2010", "Standard")
```

Тобто ніщо не заважає нам зберігати в кортежі дані одного типу.

## Тип кортежу

Тип списку рядків, як ви пам'ятаєте, `[String]`. І не важливо, скільки рядків ми запхали в список, один або мільйон &mdash; його тип залишиться незмінним. З кортежем же абсолютно-по іншому.

Тип кортежу залежить від кількості його елементів. Ось тип кортежу, що містить два рядки:

```haskell
(String, String)
```

Ось ще приклад:

```haskell
(Double, Double, Int)
```

І ще:

```haskell
(Bool, Double, Int, String)
```

Тип кортежу явно відображає його вміст. Тому якщо функція застосовується до кортежу з двох рядків, застосувати її до кортежу з трьох ніяк не вийде, адже типи цих кортежів відрізняються:

```haskell
-- Різні типи
(String, String)
(String, String, String)
```

## Дії над кортежами

Зі списками можна робити багато всього, а от з кортежами &mdash; не дуже. Найчастіші дії &mdash; власне формування кортежу і добування даних. Наприклад:

```haskell
makeAlias :: String -> String -> (String, String)
makeAlias host alias = (host, alias)
```

Мабуть, нічого простішого придумати не можна: на вході два аргументи, на виході &mdash; двоелементний кортеж з цими аргументами. Двоелементний кортеж називають ще парою (англ. pair). І хоча кортеж може містити скільки завгодно елементів, на практиці саме пари зустрічаються найчастіше.

Зверніть увагу, наскільки легко створюється кортеж. Причина цього &mdash; вже знайомий нам патерн матчінг:

```haskell
makeAlias host alias = (host, alias)

          ____          ____

               =====          =====
```

Ми просто вказуємо відповідність між лівою і правою сторонами визначення: &laquo;Нехай перший елемент пари дорівнює аргументу `host`, а другий &mdash; аргументу `alias`&raquo;. Нічого зручнішого і простішого й придумати не можна. І якщо б ми хотіли отримати кортеж з трьох елементів, це виглядало б так:

```haskell
makeAlias :: String -> String -> (String, String, String)
makeAlias host alias = (host, "https://" ++ host, alias)
  
          ____          ____                ____

               =====                              =====
```

Оператор `++` &mdash; це оператор конкатенації, склеює два рядки в один. Строго кажучи, він склеює два списки, але ми-то з вами вже знаємо, що `String` є ніщо інше, як `[Char]`. Таким чином, `"https://"` ++ `"www.google.com"` дає нам `"https://www.google.com"`.

Витяг елементів з кортежу також проводиться через патерн матчінг:

```haskell
main :: IO ()
main =
  let (host, alias) = makeAlias "173.194.71.106"
                                "www.google.com"
  in print (host ++ ", " ++ alias)
```

Функція `makeAlias` дає нам пару з хоста й імені. Але що це за дивний запис біля вже знайомого нам слова `let`? Це проміжний вираз, але вираз хитрий, утворений через патерн матчінг. Щоб було зрозуміліше, спочатку перепишемо функцію без нього:

```haskell
main :: IO ()
main =
  let pair = makeAlias "173.194.71.106"
                       "www.google.com"
      host = fst pair -- Беремо перше...
      alias = snd pair -- Беремо друге...
  in print (host ++ ", " ++ alias)
```

При запуску цієї програми отримаємо:

```bash
"173.194.71.106, www.google.com"
```

Стандартні функції `fst` і `snd` повертають перший та другий елемент кортежу відповідно. Вираз `pair` відповідає парі, вираз `host` &mdash; значенню хоста, а `alias` &mdash; значенню імені. Але чи не здається вам такий спосіб надмірним? Ми в Haskell любимо витончені рішення, тому віддаємо перевагу патерн матчінгу. Ось як виглядає вищенаведений спосіб:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
let (host, alias) = ("173.194.71.106", "www.google.com")

                     дане значення
     це
     хост
                                       а ось це значення
           це
           ім'я
```

Ось така проста магія. Функція `makeAlias` дає нам пару, і ми достовірно знаємо це! А якщо знаємо, нам не потрібно вводити проміжні вирази на кшталт `pair`. Ми відразу кажемо:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"

                    ми точно знаємо, що вираз,
                    обчислений цією функцією
     це ось
     така пара
```

Це &laquo;дзеркальна&raquo; модель: через патерн матчінг формуємо:

```haskell
-- Формуємо праву сторону
-- на основі лівої...
host alias = (host, alias)

>>>>          >>>>

     >>>>>          >>>>>
```

і через нього ж отримуємо:

```haskell
-- Формуємо ліву сторону
-- на основі правої...
(host, alias) = ("173.194.71.106", "www.google.com")

 <<<<            <<<<<<<<<<<<<<<<

       <<<<<                       <<<<<<<<<<<<<<<<
```

Ось ще один приклад роботи з кортежем через патерн матчінг:

```haskell
chessMove :: String
             -> (String, String)
             -> (String, (String, String))
chessMove color (from, to) = (color, (from, to))

main :: IO ()
main = print (color ++ ": "++ from ++ "-" ++ to)
  where
    (color, (from, to)) = chessMove "white" ("e2", "е4")
```

І на виході отримуємо:

```bash
"white: e2-e4"
```

Зверніть увагу, оголошення функції відформатоване трохи інакше: типи вишикувані один за одним через вирівнювання стрілок під двокрапкою. Ви часто зустрінете такий стиль в Haskell-проектах.

Функція `chessMove` дає нам кортеж з кортежем, а оскільки ми точно знаємо вигляд цього кортежу, відразу вказуємо `where`-вираз у вигляді зразка:

```haskell
(color, (from, to)) = chessMove "white" ("e2", "е4")

 _____                          _______

         ====                            ====

               ..                              ....
```

До речі, я про це не згадав, але теоретично кортеж може складатися й з одного елемента:

```haskell
useless :: String -> (String)
useless s = (s)

main :: IO ()
main = putStrLn s
  where (s) = useless "some"
```

Втім, враховуючи гетерогенність кортежу, мені важко уявити ситуацію, в якій одноелементний кортеж був би реально корисним.

## Не всі

Ми можемо витягувати за зразком лише частину потрібної нам інформації. Пам'ятаєте універсальний зразок `_`? Погляньте:

```haskell
-- Пояснюючі псевдоніми
type UUID = String
type FullName = String
type Email = String
type Age = Int
type Patient = (UUID, FullName, Email, Age)

patientEmail :: Patient -> Email
patientEmail (_, _, email, _) = email

main :: IO ()
main =
  putStrLn (patientEmail ( "63ab89d"
                         , "John Smith"
                         , "johnsm@gmail.com"
                         , 59
                         ))
```

Функція `patientEmail` дає нам пошту пацієнта. Тип `Patient` &mdash; це псевдонім для кортежу з чотирьох елементів: унікальний ідентифікатор, повне ім'я, адреса електронної пошти та вік. Додаткові псевдоніми роблять наш код зрозумілішим: одна справа бачити безликий `String` і зовсім інша &mdash; `Email`.

Розглянемо внутрішню будову функції `patientEmail`:

```haskell
patientEmail (_, _, email, _) = email
```

Функція говорить нам: &laquo;Так, я знаю, що мій аргумент &mdash; це чотирьохелементний кортеж, але мене в ньому цікавить виключно третій елемент, відповідний поштовій адресі, його я і  поверну&raquo;. Універсальний зразок `_` робить наш код лаконічнішим і зрозумілішим, адже він допомагає нам ігнорувати те, що нам нецікаво. Строго кажучи, ми не зобов'язані використовувати `_`, але з ним буде краще.

## А якщо помилилися?

При використанні патерн матчінгу щодо пари слід бути уважним. Уявімо собі, що вищезгаданий тип `Patient` був розширений:

```haskell
type UUID = String
type FullName = String
type Email = String
type Age = Int
type DiseaseId = Int -- Новий елемент.
type Patient = ( UUID
               , FullName
               , Email
               , Age
               , DiseaseId
               )   
```

Додано ідентифікатор захворювання. І все було б добре, але внести зміни у функцію `patientEmail` ми забули:

```haskell
patientEmail :: Patient -> Email
patientEmail (_, _, email, _) = email
 
              ^  ^  ^      ^ -- А п'ятий де?
```

На щастя, в цьому випадку компілятор строго зверне нашу увагу на помилку:

```bash
Couldn't match type '(t0, t1, String, t2)'
with '(UUID, FullName, Email, Age, DiseaseId)'
Expected type: Patient
Actual type: (t0, t1, String, t2)
In the pattern: (_, _, email, _)
```

Воно й зрозуміло: функція `patientEmail` використовує зразок, який вже є некоректним. Ось чому при використанні патерн матчінгу слід бути уважним.

На цьому наше знайомство з кортежами вважаю завершеним, у наступних розділах ми будемо використовувати їх періодично.

## Для допитливих

Для роботи з елементами багатоелементних кортежів можна використовувати готові бібліотеки, задля уникнення довгих патерн матчінгових ланцюжків. Наприклад, пакет [tuple](http://hackage.haskell.org/package/tuple):

```haskell
Data.Tuple.Select

main :: IO ()
main = print (sel4 (123, 7, "hydra", "DC:4", 44, "12.04"))
```

Функція `sel4` з модуля `Data.Tuple.Select` витягує четвертий елемент кортежу, в даному випадку рядок `"DC:4"`. Там є функції аж до `sel32`, автори цілком розумно визнали, що ніхто, будучи в здоровому глузді, не стане оперувати кортежами, що складаються з більш ніж 32 елементів.

Крім того, ми й оновлювати елементи кортежу можемо:

```haskell
import Data.Tuple.Update

main :: IO ()
main = print (upd2 2 ("si", 45))
```

Природно, унаслідок незмінності кортежу, ніякого оновлення тут не відбувається, але виглядає симпатично. При запуску отримуємо результат:

```bash
("si",2)
```

