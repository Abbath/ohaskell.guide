# Hackage і бібліотеки

Раніше я вже згадував про бібліотеки, прийшов час познайомитися з ними ближче, адже в наступних розділах ми будемо використовувати їх постійно.

## Бібліотеки великі і маленькі

За роки існування Haskell розробники з усього світу створили безліч бібліотек. Бібліотеки рятують нас від необхідності знову і знову писати те, що вже написано до нас. Для будь-якої живої мови програмування написано безліч бібліотек. У світі Haskell їх, звичайно, не така хмара, як для тієї ж Java, але порядно: стабільних є не менше двох тисяч, багато з яких дуже якісні і вже багаторазово випробувані в серйозних проектах.

З модулями &mdash; файлами, що містять Haskell-код, &mdash; ми вже знайомі, вони є основними цеглинами будь-якого Haskell-проекту. Бібліотека, будучи Haskell-проектом, теж складається з модулів (не важливо, з одного або з сотень). Тому використання бібліотеки зводиться до використання модулів, які в неї входять. І ми вже неодноразово робили це в попередніх розділах.

Згадаймо приклад з розділу про ФВП:

```haskell
import Data.Char

toUpperCase :: String -> String
toUpperCase str = map toUpper str

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org"
```

Функція `toUpper` визначена в модулі `Data.Char`, який, у свою чергу, живе в стандартній бібліотеці. Бібліотек є безліч, але стандартна лише одна. Вона містить основні, найбільш широко використовувані інструменти. А перш ніж продовжити, задамося важливим питанням: &laquo;Де живуть всі ці бібліотеки?&raquo; Вони живуть у різних місцях, але головне з них &mdash; Hackage.

## Hackage

Hackage &mdash; це центральний репозиторій Haskell-бібліотек, або, як прийнято у нас називати, пакетів (англ. package). Назва репозиторію походить від злиття слів `Haskell` і `package`. Hackage існує з 2008 року і живе [тут](http://hackage.haskell.org/). Раніше згадана стандартна бібліотека теж живе в Hackage і називається вона `base`. Кожній бібліотеці виділена своя сторінка.

Кожен з Hackage-пакетів живе за адресою, сформованою за незмінною схемою: `http://hackage.haskell.org/package/ІМ'ЯПАКЕТУ`. Так, дім стандартної бібліотеки &mdash; `http://hackage.haskell.org/package/base`. Hackage &mdash; відкритий репозиторій: будь-який розробник може додати туди свої пакети.

Стандартна бібліотека включає в себе більше сотні модулів, але є серед них найвідоміший, що носить ім'я `Prelude`. Цей модуль за замовчуванням завжди з нами: весь його вміст автоматично імпортується в усі модулі нашого проекту. Наприклад, вже відомі нам `map` або оператори конкатенації списків живуть в модулі `Prelude`, тому доступні нам завжди. Крім них (і багатьох-багатьох десятків інших функцій) в `Prelude` розташовуються функції для роботи з введенням-виведенням, такі як наші знайомі `putStrLn` і `print`.

Hackage досить великий, тому шукати пакети можна двома способами. Перший &mdash; на [єдиній сторінці всіх пакетів](http://hackage.haskell.org/packages/). Тут перераховані всі пакети, а для нашої зручності вони розташовані за тематичними категоріями.

Другий спосіб &mdash; через спеціальний пошуковик, яких є два:

1. [Hoogle](http://www.haskell.org/hoogle/)
2. [Hayoo!](http://holumbus.fh-wedel.de/hayoo/hayoo.html)

Ці пошуковики скрупульозно переглядають нутрощі Hackage, і ви будете часто ними користуватися. Особисто я віддаю перевагу [Hayoo!](http://holumbus.fh-wedel.de/hayoo/hayoo.html). Користуємося ним як звичайним пошуковиком: наприклад, ми знаємо ім'я функції, а в якому пакеті/модулі вона живе &mdash; забули. Вбиваємо в пошук &mdash; отримуємо результати.

Щоб скористатися пакетом в нашому проекті, потрібно для початку включити його в наш проект. Для прикладу розглянемо пакет `text`, призначений для роботи з текстом. Він нам знадобиться, тому включимо його в наш проект негайно.

Відкриваємо файл збірки проекту `real.cabal`, знаходимо секцію `executable real-exe` у полі `build-depends` через кому дописуємо ім'я пакета:

```haskell
build-depends: base -- Вже тут!
               , real
               , text -- А це новий пакет.
```

Файл з розширенням `.cabal` &mdash; це обов'язковий файл збірки Haskell-проекту. Він містить головні інструкції, що стосуються збирання проекту. З синтаксисом складального файлу ми будемо поступово знайомитися в наступних розділах.

Як бачите, пакет `base` вже тут. Включивши пакет `text` в секцію `build-depends`, ми оголосили тим самим, що наш проект відтепер залежить від цього пакету. Тепер, перебуваючи в корені проекту, виконуємо вже знайому нам команду:

```bash
$ stack install
```

Пам'ятаєте, коли ми вперше налаштовували проект, я згадав, що утиліта `stack` вміє ще й бібліотеки встановлювати? Вона побачить нову залежність нашого проекту і встановить сам пакет `text`, так і всі ті пакети, від яких, в свою чергу, залежить пакет `text`. Після збірки ми можемо імпортувати модулі з цього пакету в наші модулі. І тепер прийшла пора дізнатися, як це можна робити.

## Ієрархія імен

Коли ми пишемо:

```haskell
import Data.Char
```

в імені модуля відображена ієрархія пакета. `Data.Char` означає, що всередині пакету `base` каталог `Data`, всередині якого живе файл `Char.hs`, відкривши який, ми побачимо:

```haskell
module Data.Char
...
```

Таким чином, точка в імені модуля відображає файлову ієрархію всередині даного пакету. Можете сприймати цю точку як слеш в Unix-шляху. Є пакети зі значно більш довгими іменами, наприклад:

```haskell
module GHC.IO.Encoding.UTF8
```

Відповідно, імена наших власних модулів теж відображають місце, в якому вони живуть. Так, один з модулів в моєму робочому проекті носить назву `Common.Performers.Click`. Це означає, що живе цей модуль тут: `src/Common/Performers/Click.hs`.

## Обличчя

Повернемося до нашого прикладу:

```haskell
import Data.Char
```

Імпорт модуля `Data.Char` робить доступним для нас все те, що включено в інтерфейс цього модуля. Відкриємо наш власний модуль `Lib`:

```haskell
module Lib
    ( someFunc
    ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

Ім'я функції `someFunc` згадано в інтерфейсі модуля, а саме між круглими дужками, що слідують за ім'ям модуля. Трохи переформатуємо дужки:

```haskell
module Lib (
  someFunc
) where
```

Зараз тільки функція `someFunc` доступна всім імпортерам даного модуля. Якщо ж ми визначимо в цьому модулі іншу функцію `anotherFunc`:

```haskell
module Lib (
  someFunc
) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"

anotherFunc :: String -> String
anotherFunc s = s ++ "!"
```

вона залишиться невидимою для зовнішнього світу, тому що її ім'я не згадано в інтерфейсі модуля. І якщо в модулі `Main` ми напишемо так:

```haskell
module Main

import Lib

main :: IO ()
main = putStrLn . anotherFunc $ "Hi"
```

компілятор справедливо матюкнеться, мовляв, не знаю функцію `anotherFunc`. Якщо ж ми додамо її в інтерфейс модуля `Lib`:

```haskell
module Lib (
  someFunc,
  anotherFunc
) where
```

тоді функція `anotherFunc` теж стане видимою всьому світу. Інтерфейс дозволяє нам показувати оточуючим лише те, що ми хочемо їм показати, залишаючи службові нутрощі нашого модуля таємницею за сімома печатями.

## Імпортуємо по-різному

У реальних проектах ми імпортуємо безліч модулів з різних пакетів. Іноді це є причиною конфліктів, з якими доводиться мати справу.

Згадаймо функцію `putStrLn`: вона існує не тільки у незримому модулі `Prelude`, але і в модулі `Data.Text.IO` з пакету `text`:

```haskell
-- Тут теж є функція на ім’я putStrLn.
import Data.Text.IO

main :: IO ()
main = putStrLn ... -- І звідки ця функція?
```

При спробі зібрати такий код ми впремося в помилку:

```bash
Ambiguous occurrence 'putStrLn'
It could refer to either 'Prelude.putStrLn',
imported from 'Prelude' ...
or 'Data.Text.IO.putStrLn',
imported from 'Data.Text.IO' ...
```

Нам необхідно якось вказати, яку з функцій `putStrLn` ми маємо на увазі. Це можна зробити кількома способами.

Можна вказати приналежність функції до конкретного модуля. З повідомлення про помилку вже видно, як це можна зробити:

```haskell
-- Тут теж є функція на ім’я putStrLn.
import Data.Text.IO

main :: IO ()
main = Data.Text.IO.putStrLn ... -- Сумнівів немає!
```

Тепер уже сумнівів не залишилося: використовувана нами `putStrLn` належить модулю `Data.Text.IO`, тому колізій немає.

Втім, чи не здається вам така форма занадто довгою? У згаданому раніше стандартному модулі `GHC.IO.Encoding.UTF8` функція `mkUTF8`, і уявіть собі:

```haskell
import GHC.IO.Encoding.UTF8

main :: IO ()
main =
  let enc = GHC.IO.Encoding.UTF8.mkUTF8 ...
```

Занадто довго, потрібно вкоротити. Імпортуємо модуль під короткою назвою:

```haskell
import    Data.Text.IO  as  TIO

включити  цей модуль    як  це

main :: IO ()
main = TIO.putStrLn ...
```

Ось, так значно краще. Коротке ім'я може складатися навіть з однієї літери, але як і повне ім'я модуля, воно обов'язково повинно починатися з великої літери, тому:

```haskell
import Data.Text.IO as tIO -- Помилка
import Data.Text.IO as i -- Теж помилка
import Data.Text.IO as I -- Порядок!
```

Іноді, для більшого порядку, використовують qualified-імпорт:

```haskell
import qualified Data.Text.IO as TIO
```

Ключове слово `qualified` використовується для &laquo;строгого&raquo; включення модуля: в цьому випадку ми зобов'язані вказувати належність до нього. Наприклад:

```haskell
import qualified Data.Text as T

main :: IO ()
main = T.justifyLeft ...
```

Навіть незважаючи на те, що функція `justifyLeft` є тільки в модулі `Data.Text` і ніяких колізій з `Prelude " немає, ми зобов'язані вказати, що ця функція саме з `Data.Text`. У великих модулях qualified-імпорт буває корисний: з одного боку, гарантовано не буде ніяких конфліктів, з іншого, ми відразу бачимо, звідки походить та чи інша функція.

Втім, деяким Haskell-програмістам будь-яка вказівка приналежності до модуля здається надмірною. Тому вони йдуть іншим шляхом: вибіркове включення/вимикання. Наприклад:

```haskell
import Data.Char
import Data.Text (pack) -- Тільки її!

main :: IO ()
main = putStrLn $ map toUpper "haskell.org"
```

Ми маємо на увазі стандартну функцію `map`, проте в модулі `Data.Text` теж міститься функція на ім’я `map`. На щастя, ніякої колізії не буде, адже ми імпортували не весь вміст модуля `Data.Text`, а лише одну його функцію `pack`:

```haskell
import     Data.Text (pack)

імпортуємо звідси    тільки
                     це
```

Якщо ж ми хочемо імпортувати дві чи більше функції, перераховуємо їх через кому:

```haskell
import Data.Text (pack, unpack)
```

Існує і протилежний шлях: замість вибіркового включення &mdash; вибіркове вимикання. Уникнути колізії між функціями `putStrLn` можна було б і так:

```haskell
import Data.Text.IO hiding (putStrLn)

main :: IO ()
main = putStrLn ... -- Сумнівів немає: Prelude.
```

Слово `hiding` дозволяє приховувати дещо з імпортованого модуля:

```haskell
import     Data.Text.IO hiding (putStrLn)

імпортуємо всі звідси   крім   цього
```

Можна і кілька функцій приховати:

```haskell
import Data.Text.IO hiding ( readFile
                           , writeFile
                           , appendFile
                           )
```

При бажанні можна приховати і з `Prelude`:

```haskell
import Prelude hiding (putStrLn)
import Data.Text.IO

main :: IO ()
main = putStrLn ... -- Вона точно з Data.Text.IO.
```

## Оформлення

Загальна рекомендація така &mdash; оформляйте так, щоб було легше читати. В реальному проекті в кожен з ваших модулів буде імпортуватися досить багато всього. Ось шматочок з одного мого робочого модуля:

```haskell
import qualified Test.WebDriver.Commands as WDC
import           Test.WebDriver.Exceptions
import qualified Data.Text as T
import           Data.Maybe (fromJust)
import           Control.Monad.IO.Class
import           Control.Monad.Catch
import           Control.Monad (void)
```

Як повні, так і короткі імена модулів вирівняні, такий код простіше читати і змінювати. Не всі програмісти погодяться з таким стилем, але спробуємо прибрати вирівнювання:

```haskell
import qualified Test.WebDriver.Commands as WDC
import Test.WebDriver.Exceptions
import qualified Data.Text as T
import Data.Maybe (fromJust)
import Control.Monad.IO.Class
import Control.Монада.Catch
import Control.Монада (void)
```

Тепер код виглядає зім'ятим, його важче сприймати. Втім, вибір за вами.
