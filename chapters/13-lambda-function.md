# Лямбда-функція

Настав час познайомитися з важливою концепцією &mdash; лямбда-функцією. Саме з неї все і почалося. Приготуйтеся: в цьому розділі нас чекають нові відкриття.

## Витоки

У далеких 1930-х молодий американський математик [Алонзо Черч](https://ru.wikipedia.org/wiki/%D0%A7%D1%91%D1%80%D1%87,_%D0%90%D0%BB%D0%BE%D0%BD%D0%B7%D0%BE) замислився над тим, що означає &laquo;обчислити&raquo;. Плодом його роздумів стала система для формалізації поняття &laquo;обчислення&raquo;, і назвав він її &laquo;лямбда-численням&raquo; (англ. lambda calculus, від імені грецької літери `λ`). В основі цієї системи лежить лямбда-функція, яку можна вважати &laquo;матір'ю функціонального програмування&raquo; в цілому і Haskell зокрема. Далі буду називати її ЛФ.

Щодо ЛФ можна сміливо сказати: &laquo;Все геніальне просто&raquo;. Ідея ЛФ настільки корисна саме тому, що вона гранично проста. ЛФ &mdash; це анонімна функція. Ось як вона виглядає в Haskell:

```haskell
\x -> x * x
```

Зворотний слеш на початку &mdash; ознака ЛФ. Порівняйте з математичною формою запису:

```haskell
λx . x * x
```

Схоже, чи не правда? Сприймайте зворотний слеш у визначенні ЛФ як спинку літери `λ`.

ЛФ являє собою найпростіший вид функції, це така функція, роздягнена догола. У неї забрали не тільки оголошення, але й ім'я, залишивши лише необхідний мінімум у вигляді імен аргументів і внутрішнього виразу. Алонзо Черч зрозумів: щоб застосувати функцію, зовсім необов'язково її іменувати. І якщо у звичайній функції спочатку йде оголошення/визначення, а потім (десь) застосування з використанням імені, то у ЛФ все значно простіше: ми її визначаємо і тут же застосовуємо, на місці. Ось так:

```haskell
(\x -> x * x) 5
```

Пам'ятаєте функцію `square`? Ось це її лямбда-аналог:

```haskell
(\x -> x * x)      5

лямбда-абстракція  аргумент
```

Лямбда-абстракція (англ. lambda abstraction) &mdash; це осоьливий вираз, який породжує функцію, яку ми відразу ж застосовуємо до аргументу `5`. ЛФ з одним аргументом, як і просту функцію, ще називають &laquo;ЛФ від одного аргументу&raquo; чи &laquo;ЛФ одного аргументу&raquo;. Також можна казати й &laquo;лямбда-абстракцію одного аргументу &raquo;

## Побудова

Побудова лямбда-абстракції гранично проста:

```haskell
\      x ->      x * x
ознака ім'я      вираз
ЛФ     аргументу
```

Відповідно, якщо ЛФ застосовується до двох аргументів &mdash; пишемо так:

```haskell
\      x         y ->      x * y
ознака ім'я 1    ім'я 2    вираз
ЛФ     аргументу аргументу
```

І коли ми застосовуємо таку функцію:

```haskell
(\x y -> x * y) 10 4
```

то просто підставляємо `10` на місце `x`, `4` &mdash; на місце `y`, і отримуємо вираз `10 * 4`:

```haskell
(\x y -> x * y) 10 4 
= 10 * 4 
= 40
```

Загалом, все як зі звичайною функцією, навіть простіше.

Ми можемо ввести проміжне значення для лямбда-абстракції:

```haskell
main :: IO ()
main = print (mul 10 4)
  where mul = \x y -> x * y
```

Тепер ми можемо застосовувати `mul` так само, ніби це сама лямбда-абстракція:

```haskell
  mul 10 4 
= (\x y -> x * y) 10 4 
= 10 * 4
```

І тут ми наблизилися до одного важливого відкриття.

## Тип функції

Ми знаємо, що у всіх даних в Haskell-програмі обов'язково є якийсь тип, який уважно перевіряється на етапі компіляції. Питання: який тип у виразу `mul` з попереднього прикладу?

```haskell
where mul = \x y -> x * y -- Який тип?
```

Відповідь проста: тип `mul` такий же, як і у цієї лямбда-абстракції. З цього ми робимо важливий висновок: ЛФ має тип, як і звичайні дані. Але оскільки ЛФ є окремим випадком функції &mdash; значить і у звичайної функції теж є тип!

В нефункційних мовах між функціями і даними проведена чітка межа: ось це функції, а ось це &mdash; дані. Проте в Haskell між даними і функціями різниці немає, адже і те й інше спочиває на одній і тій же Черепасі. Ось тип функції `mul`:

```haskell
mul :: a -> a -> a
```

Почекайте, скажете ви, але ж це оголошення функції! Абсолютно вірно: оголошення функції &mdash; це і є вказівка її типу. Пам'ятаєте, коли ми вперше познайомилися з функцією, я уточнив, що її оголошення розділене подвійною двокрапкою? Так ось ця подвійна двокрапка і являє собою вказівку типу:

```haskell
mul ::  a -> a -> a

ось має |   от    |
це  тип |_ такий _|
```

Точно так само ми можемо вказати тип будь-яких інших даних:

```haskell
let coeff = 12 :: Double
```

Хоча ми знаємо, що в Haskell типи виводяться автоматично, іноді ми хочемо взяти цю турботу на себе. В даному випадку ми говоримо: &laquo;Нехай вираз `coeff` буде `12`, але тип його нехай буде `Double`, а не `Int`&raquo;. Так само і з функцією: коли ми оголошуємо її &mdash; ми тим самим вказуємо її тип.

Але ви запитаєте, чи можемо ми не вказувати тип функції явно? Можемо:

```haskell
square x = x * x
```

Це наша стара знайома, функція `square`. Коли вона буде застосована до значення типу `Int`, тип аргументу буде виведений автоматично як `Int`.

І оскільки функція характеризується типом так само, як й інші дані, ми робимо ще одне важливе відкриття: функціями можна оперувати як даними. Наприклад, можна створити список функцій:

```haskell
main :: IO ()
main = putStrLn ((head functions) "Hi")
 where
   functions = [ \x -> x ++ "val1"
               , \x -> x ++ "val2"
               ]
```

Вираз `functions` &mdash; це список з двох функцій. Два лямбда-вирази породжують ці дві функції, але до моменту застосування вони нічого не роблять, вони неживі і марні. Але коли ми застосовуємо функцію `head` до цього списку, ми отримуємо перший елемент списку, тобто першу функцію. І отримавши, тут же застосовуємо цю функцію до рядка `"Hi"`:

```haskell
putStrLn ((head functions) "Hi")

           |   перша    |  її
           |   функція  |  аргумент
           |__ списку __|
```

Це рівносильно кодові:

```haskell
putStrLn ((\x -> x ++ "val1") "Hi")
```

При запуску програми ми отримаємо:

```bash
Hi val1
```

До речі, а який тип списку `functions`? Його тип такий: `[String -> String]`. Тобто список функцій з одним аргументом типу `String`, які повертають значення типу `String`.

## Локальні функції

Раз вже між ЛФ та простими функціями фактично немає розходжень, а функції є частковим випадком даних, ми можемо створювати функції локально для інших функцій:

```haskell
-- Тут визначені функції
-- isInfixOf і isSuffixOf.
import Data.List

validComEmail :: String -> Bool
validComEmail email =
containsAtSign email && endsWithCom email
  where
    containsAtSign e = "@" `isInfixOf` e
    endsWithCom e = ".com" `isSuffixOf` e

main :: IO ()
main = putStrLn (if my validComEmail
  then "it's ok!"
  else "Non-com email!")
  where
    my = "haskeller@gmail.com"
```

Дещо наївна функція `validComEmail` перевіряє `.com`-адресу. Її вираз утворено оператором `&&` і двома виразами типу `Bool`. Ось як утворені ці вирази:

```haskell
containsAtSign e = "@" `isInfixOf` e
endsWithCom e = ".com" `isSuffixOf` e
```

Це &mdash; дві функції, які ми визначили прямо в `where`-секції, тому вони існують тільки для основного виразу функції `validComEmail`. З простими функціями так роблять дуже часто: де вона потрібна, там її і визначають. Ми могли б написати і більш явно:

```haskell
validComEmail :: String -> Bool
validComEmail email =
  containsAtSign email && endsWithCom email
  where
    -- Оголошуємо локальну функцію явно.
    containsAtSign :: String -> Bool
    containsAtSign e = "@" `isInfixOf` e
    -- І цю теж.
    endsWithCom :: String -> Bool
    endsWithCom e = ".com" `isSuffixOf` e
```

Втім, вказувати тип настільки простих функцій, як правило, необов'язково.

Ось як цей код виглядає з лямбда-абстракціями:

```haskell
validComEmail :: String -> Bool
validComEmail email =
  containsAtSign email && endsWithCom email
  where
    containsAtSign = \e -> "@" `isInfixOf` e
    endsWithCom = \e -> ".com" `isSuffixOf` e
```

Тепер вирази `containsAtSign` і `endsWithCom` прирівняні до ЛФ від одного аргументу. У цьому випадку ми не вказуємо тип цих виразів. Втім, якщо дуже хочеться, можна вказати:

```haskell
containsAtSign = 
  (\e -> "@" `isInfixOf` e) :: String -> Bool
  
  
  лямбда-абстракція            тип цієї абстракції
```

Лямбда-абстракцію взято в дужки, щоб оголошення типу відносилося до функції в цілому, а не тільки до аргументу `e`:

```haskell
containsAtSign = 
  \e -> "@" `isInfixOf` e :: String -> Bool

                             тип аргументу e,
                             а зовсім не всієї
                             функції!
```

Типу функції теж можна надати псевдонім:

```haskell
-- Псевдонім типу функції.
type Func = String -> Bool

validComEmail :: String -> Bool
validComEmail email =
containsAtSign email && endsWithCom email
  where
    containsAtSign = (\e -> "@" `isInfixOf` e) :: Func
    endsWithCom = (\e -> ".com" `isSuffixOf` e) :: Func
```

Втім, на практиці вказівка типу для лямбда-абстракції зустрічається вкрай рідко, бо не є потрібною.

Віднині, познайомившись з ЛФ, ми будемо періодично їх використовувати.

І наостанок, питання. Пам'ятаєте тип функції `mul`?

```haskell
mul :: a -> a -> a
```

Що це за буква `a`? По-перше, ми не зустрічали такий тип раніше, а по-друге, хіба ім'я типу в Haskell не зобов'язане починатися з великої літери? Зобов'язане. А вся справа в тому, що літера `a` в даному випадку &mdash; це не зовсім ім'я типу. А от що це таке, ми дізнаємося в одному з наступних розділів.

## Для допитливих

А чому, власне, лямбда? Чому Черч вибрав саме цю грецьку букву? За однією з версій, це сталося випадково.

Йшли 30-ті роки минулого століття, комп'ютерів не було, і всі наукові роботи набиралися на друкарських машинках. У первісному варіанті, щоб виділяти ім'я аргументу ЛФ, Черч ставив над ім'ям аргументом символ, схожий на `^`. Але коли він здавав роботу набірнику, то згадав, що друкарська машинка не зможе відтворити такий символ над буквою. Тоді він виніс цей &laquo;дашок&raquo; перед ім'я аргументу, і вийшло щось на кшталт:

```haskell
^x . x * 10
```

А набірник, побачивши такий символ, використав велику грецьку букву `Λ`:

```haskell
Λx . x * 10
```

Ось так і вийшло лямбда-числення.
