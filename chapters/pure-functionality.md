# Чистая функциональность

Haskell - чисто функциональный язык программирования. Разберёмся, что это значит.

## Императивный подход

По историческим причинам наиболее популярным подходом к написанию программ является императивный подход (от английского imperative, приказание). При таком подходе программа представляет собой набор инструкций, изменяющих состояние данной программы. Думайте об этом как о совокупности приказаний: "Сделай это, а вот теперь сделай то, после чего сделай сё". Поэтому в любом императивном языке программирования обязательно присутствует оператор присваивания, позволяющий изменять состояние тех или иных переменных. Собственно, потому они и называются "переменными".

Более того, раз есть чёткие приказания, значит есть и столь же чёткий порядок их выполнения. Если в программе, написанной на старом добром C, мы увидим вот такой кусочек:

```C
int main() {
    int r1 = f1(10);
    int r2 = f2(20);
    printf("r1 = %d, r2 = %d\n", r1, r2);
}
```

то можем с абсолютной уверенностью утверждать, что функция `f2` будет вызвана лишь после завершения работы функции `f1`, и так будет всегда. В каком порядке нами написано - в таком и выполнено будет.

## Декларативный подход

Декларативный подход (от английского declarative, описание) принципиально иной. В этом случае программа представляет собой набор выражений (англ. expression), вычисление которых в конечном итоге даст интересующий нас результат. Теперь мы сфокусированы не на процессе работы программы, а на конечном результате этой работы. Именно поэтому мы уже не задаём жёсткий порядок вычисления выражений, а значит, если мы видим такой код:

```haskell
main = print ("r1 = " ++ r1 ++ ", r2 = " ++ r2)
  where r1 = f1 10
        r2 = f2 20
```

то порядок вызова функций `f1` и `f2` нам не только неизвестен, но и неинтересен! Мы как бы говорим: "Дай нам строку с результами, и нам всё равно, в каком порядке будут вызваны эти две функции".

Более того, при декларативном подходе оператор присваивания становится ненужным, ведь теперь мы думаем уже не об изменении значений тех или иных переменных, но о вычислении выражений. Поэтому знак равенства в последнем примере - это вовсе не оператор присваивания, это объявление равенства, в математическом смысле этого слова. Впрочем, об этом мы поговорим подробнее чуть позже.

## В сухом остатке

1. Императивная парадигма - это фокус на процессе работы программы.
2. Декларативная парадигма - это фокус на результате работы программы. Haskell - из этой оперы.
