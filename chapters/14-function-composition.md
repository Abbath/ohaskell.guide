# Композиція функцій

Цей розділ розповідає про те, як об'єднувати функції в ланцюжки, а також про те, як позбутися круглих дужок.

## Дужкам &mdash; бій!

Так, я не люблю круглі дужки. Вони роблять код візуально надлишковим, до того ж потрібно стежити за симетрією відкриваючих і закриваючих дужок. Згадаймо приклад з розділу про кортежі:

```haskell
main :: IO ()
main =
  putStrLn (patientEmail ( "63ab89d"
           ^             , "John Smith"
                         , "johnsm@gmail.com"
                         , 59
                         ))
                          ^
```

З дужками кортежу ми нічого зробити не можемо, адже вони є синтаксичною частиною кортежу. А ось дужки навколо застосування функції `patientEmail` мені абсолютно не подобаються. На щастя, ми можемо позбутися від них. Але перш ніж викорінювати дужки, подумаємо ось про що.

Якщо застосування функції є виразом, чи можемо ми якось компонувати їх одне з одним? Звичайно можемо, ми вже робили це багато разів, згадайте:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

Тут компонуються дві функції, `putStrLn` і `checkLocalhost`, тому що тип виразу на виході функції `checkLocalhost` збігається з типом виразу на вході функції `putStrLn`. Схематично це можна зобразити так:

```haskell
          +--------------+            +--------+
String -> |checkLocalhost|-> String ->|putStrLn|-> ...
          +--------------+            +--------+

IP-адреса                    повідомлення          текст
                             про цю                в нашому
                             IP-адресу             терміналі
```

Виходить такий собі конвеєр: на вході рядок з IP-адресою, на виході &mdash; повідомлення у нашому терміналі. Існує інший спосіб поєднання двох функцій в одну.

## Композиція та застосування

Погляньте:

```haskell
main :: IO ()
main = putStrLn . checkLocalhost $ "173.194.22.100"
```

Незвично? Перед нами два нових стандартних оператора, які позбавляють нас від зайвих дужок і роблять наш код простішим. Оператор `.` &mdash; це оператор композиції функцій (англ. function composition), а оператор `$` &mdash; це оператор застосування (англ. application operator). Ці оператори часто використовують спільно один з одним. І відтепер ми будемо використовувати їх чи не в кожному розділі.

Оператор композиції об'єднує дві функції в одну (або компонує їх, англ. compose). Коли ми пишемо:

```haskell
putStrLn . checkLocalhost
```

відбувається маленька &laquo;магія&raquo;: дві функції об'єднуються в нову функцію. Згадаймо наш конвеєр:

```haskell
         +--------------+            +--------+
String ->|checkLocalhost|-> String ->|putStrLn|-> ...
         +--------------+            +--------+

A                           B                     C
```

Якщо нам потрібно потрапити з точки `A` точку `C`, чи можна зробити це відразу? Можна, і в цьому полягає суть композиції: ми беремо дві функції і об'єднуємо їх в третю функцію. Раз `checkLocalhost` приводить нас з точки `A` точку `B`, а функція `putStrLn` &mdash; з точки `B` в `C`, тоді композиція цих двох функцій буде представляти собою функцію, що приводить нас відразу з точки `A` в точку `C`:

```haskell
         +-------------------------+
String ->|checkLocalhost + putStrLn|-> ...
         +-------------------------+

A                                      C
```

В даному випадку знак `+` не відноситься до конкретного оператора, я лише показую факт &laquo;об'єднання&raquo; двох функцій в третю. Тепер нам зрозуміло, чому в типі функції як роздільник використовується стрілка:

```haskell
checkLocalhost :: String -> String
```

у нашому прикладі це:

```haskell
checkLocalhost :: A -> B
```

Вона показує наш рух з точки `A` точку `B`. Тому часто говорять про &laquo;функції з `A` в `B`&raquo;. Так, про функцію `checkLocalhost` можна сказати як про &laquo;функцію з `String` в `String`&raquo;.

А оператор застосування працює ще простіше. Без нього код був би таким:

```haskell
main :: IO ()
main =
  (putStrLn . checkLocalhost) "173.194.22.100"

  об'єднана функція           аргумент
```

Але ми хотіли позбутися круглих дужок, а тут вони знову. Ось для цього і потрібен оператор застосування. Його схема проста:

```haskell
FUNCTION $ ARGUMENT
оця        застосовується до  
функція    цього аргументу
```

Для нашої об'єднаної функції це виглядає так:

```haskell
main :: IO ()
main =
  putStrLn . checkLocalhost $              "173.194.22.100"

  об'єднана функція         застосовується
                            до             цього аргументу
```

Тепер вийшов справжній конвеєр: праворуч у нього &laquo;заїжджає&raquo; рядок і рухається &laquo;крізь&raquo; функції, а зліва &laquo;виїжджає&raquo; результат:

```haskell
main = putStrLn . checkLocalhost $  "173.194.22.100"

     <-         <-               <- аргумент
```

Щоб було легше читати композицію, замість оператора `.` подумки підставляємо фразу &laquo;застосовується після&raquo;:

```haskell
putStrLn .              checkLocalhost

ця       застосовується цієї
функція  після          функції
```

Тобто композиція правоасоціативна (англ. right-associative): спочатку застосовується функція праворуч, а потім &mdash; ліворуч.

Ще одне зауваження про оператор застосування функції. Він дуже гнучкий, і ми можемо написати так:

```haskell
main = putStrLn . checkLocalhost $ "173.194.22.100"

       об'єднана функція           |_ її аргумент_|
```

а можемо і так:

```haskell
main = putStrLn $ checkLocalhost "173.194.22.100"

       звичайна   |________ її аргумент ________|
       функція
```

Ці дві форми, як ви вже зрозуміли, еквівалентні. Я показую це для того, щоб знову і знову продемонструвати вам, наскільки гнучко працювати з даними і функціями в Haskell.

## Довгі ланцюжки

Краса композиції в тому, що компонувати ми можемо стільки функцій, скільки нам заманеться:

```haskell
logWarn :: String -> String
logWarn rawMessage =
  warning . correctSpaces . asciiOnly $ rawMessage

main :: IO ()
main = putStrLn $
  logWarn "Province 'Gia Viễn' isn't on the map! "
```

Функція `logWarn` готує переданий їй рядок для запису в журнал. Функція `asciiOnly` готує рядок висновку в нелокалізованому терміналі (так, у 2016 році такі все ще є), функція `correctSpaces` прибирає подвійні пробіли, а функція `warning` робить рядок попередженням (наприклад, додає рядок `"WARNING: "` на початку повідомлення). При запуску цієї програми ми побачимо:

```bash
WARNING: Province 'Gia Vi?n' isn't on the map!
```

Тут ми об'єднали в &laquo;функціональний конвеєр&raquo; вже три функції, без будь-яких дужок. Ось як це вийшло:

```haskell
warning . correctSpaces . asciiOnly $ rawMessage

          ============= ^ =========

          |__  перша композиція __|

+++++++ ^ +++++++++++++++++++++++++

| _______ друга композиція _______|
                                      аргумент
```

Перша композиція об'єднує дві прості функції, `correctSpaces` і `asciiOnly`. Друга об'єднує теж дві функції, просту `warning` і об'єднану, яка є результатом першої композиції.

Більше того, визначення функції `logWarn` можна зробити ще більш простим:

```haskell
logWarn :: String -> String
  logWarn = warning . correctSpaces . asciiOnly
```

Стривайте, але де ж ім'я аргументу? А його більше немає, воно нам не потрібно. Адже ми знаємо, що застосування функції можна легко замінити внутрішнім виразом функції. А раз так, вираз `logWarn` може бути замінено на вираз `warning . correctSpaces . asciiOnly`. Давайте це зробимо:

```haskell
logWarn "Province 'Gia Viễn' isn't on the map! "=

(warning
 . correctSpaces
 . asciiOnly) "Province 'Gia Viễn' isn't on the map! "=

warning
. correctSpaces
. asciiOnly $ "Province 'Gia Viễn' isn't on the map! "
```

І все працює! У світі Haskell прийнято саме так: якщо щось може бути спрощено &mdash; ми спрощуємо.

Заради справедливості слід зауважити, що не всі Haskell-розробники люблять позбавлятися від круглих дужок, деякі вважають за краще використовувати саме їх. Що ж, це питання лише стилю та звичок.

## Як працює композиція

Якщо раптом ви подумали, що оператор композиції унікальний і вбудований в Haskell &mdash; поспішаю вас розчарувати. Ніякої магії, все гранично просто. Цей стандартний оператор визначений так само, як і будь-яка інша функція. Ось його визначення:

```haskell
(.) f g = \x -> f (g x)
```

Опа! Та тут і справді немає нічого особливого. Оператор композиції застосовується до двох функцій. Стоп, скажете ви, як це? Застосовується до функцій? Так, саме так. Адже ми вже з'ясували, що функціями можна оперувати як даними. А раз так, що нам заважає передати функцію як аргумент для іншої функції? Що нам заважає повернути функцію з іншої функції? Нічого.

Оператор композиції отримує на вхід дві функції, а потім лише дає нам ЛФ, всередині якої відбувається звичайний послідовний виклик цих двох функцій через дужки. І ніякої магії:

```haskell
(.)    f       g       = \x -> f (g x)

беремо цю      цю        і повертаємо
       функцію функцію   ЛФ, всередині
                         якої
                         викликаємо їх
```

Підставимо наші функції:

```haskell
(.) putStrLn checkLocalhost = \x -> putStrLn (checkLocalhost x)
```

Ось так і відбувається &laquo;об'єднання&raquo; двох функцій: ми просто повертаємо ЛФ від одного аргументу, всередині якої правоасоціативно викликаємо обидві функції. Аргументом в даному випадку є той самий рядок з IP-адресою:

```haskell
(\x -> putStrLn (checkLocalhost x)) "173.194.22.100" =

putStrLn (checkLocalhost "173.194.22.100"))
```

Але якщо я вас ще не переконав, давайте визначимо власний оператор композиції функцій! Пам'ятаєте, я казав вам, що ASCII-символи можна гнучко поєднувати в оператори? Давайте візьмемо плюс зі стрілками, він чимось схожий на об'єднання. Пишемо:

```haskell
-- Наш власний оператор композиції.
(<+>) f g = \x -> f (g x)

...

main :: IO ()
main = putStrLn <+> checkLocalhost $ "173.194.22.100"
```

Виглядає незвично, але працювати буде так, як і очікується: ми визначили власний оператор `<+>` з тим же функціоналом, що і стандартний оператор композиції. Тому можна написати ще простіше:

```haskell
(<+>) f g = f . g
```

Ми кажемо: &laquo;Нехай оператор `<+>` буде еквівалентний стандартному оператору композиції функцій.&raquo;. І так воно й буде. А можна &mdash; не повірите &nbsp; ще простіше:

```haskell
f <+> g = f . g
```

І це буде працювати! Раз оператор призначений для інфіксного застосування, то ми, визначаючи його, можемо відразу вказати його в інфіксній формі:

```haskell
f <+> g =      f . g

        нехай
такий
вираз
        буде
        рівним
               такому
               виразу
```

Тепер ми бачимо, що в композиції функцій немає нічого надприродного. На цьому я наголошую протягом всієї книги: Haskell не має ніякої магії, він логічний і послідовний.
