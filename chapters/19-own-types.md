# Наші типи

Ось ми й дісталися до Другого Кита Haskell &mdash; до **Типів**. Звісно, ми працювали з типами майже з самого початку, але вам вже добряче набридли всі ці `Int` та `String`, чи не так? Прийшла пора познайомитися з типами значно ближче.

## Знайомство

Дивно, але в Haskell дуже мало вбудованих типів, тобто таких, про які компілятор знає з самого початку. Є `Int`, є `Double`, `Char`, ну і ще кілька. Всі ж інші типи, які навіть носять статус стандартних, не є вбудованими в мову. Замість цього вони визначені в стандартній чи інших бібліотеках, причому визначені точно так само, як ми будемо визначати і наші власні типи. А оскільки без своїх типів написати якусь серйозну програму в нас не вийде, ця тема гідна найпильнішого погляду.

Визначимо тип `Transport` для двох відомих протоколів транспортного рівня моделі OSI:

```haskell
data Transport = TCP | UDP
```

Перед нами &mdash; дуже простий, але вже наш власний тип. Розглянемо його уважніше.

Ключове слово `data` &mdash; це початок визначення типу. Далі йде назва типу, в даному випадку `Transport`. Ім'я будь-якого типу повинно починатися з великої літери. Потім йде знак рівності, після якого починається фактичний опис типу, його &laquo;тіло&raquo;. В даному випадку воно складається з двох найпростіших конструкторів. Конструктор значення (англ. data constructor) &mdash; це те, що конструює значення даного типу. Тут у нас два конструктора, `TCP` і `UDP`, кожен з яких конструює значення типу `Transport`. Ім'я конструктора теж повинно починатися з великої літери. Іноді для лаконічності конструктор значення називають просто конструктором.

Таке визначення легко читається:

```haskell
data Transport =  TCP |   UDP

тип  Transport це TCP або UDP
```

Тепер ми можемо використовувати тип `Transport`, тобто створювати значення цього типу і щось з ними робити. Наприклад, в `let`-виразі:

```haskell
let protocol = TCP
```

Ми створили значення `protocol` типу `Transport`, використавши конструктор `TCP`. А можна й так:

```haskell
let protocol = UDP
```

Хоча ми використовували різні конструктори, тип значення `protocol` в обох випадках один і той самий &mdash; `Transport`.

Розширити подібний тип дуже просто. Додамо новий протокол SCTP (Stream Transmission Control Protocol):

```haskell
data Transport = TCP | UDP | SCTP
```

Третій конструктор значення дав нам третій спосіб створення значення типу `Transport`.

## Значення-пустушка

Замислимося: коли ми говоримо про значення типу `Transport` &mdash; про що насправді йде мова? Здавалося б, значення фактично немає: ні числа, ні рядка, просто три конструктори. Так ось вони і є значеннями. Коли ми пишемо:

```haskell
let protocol = SCTP
```

ми створюємо значення типу `Transport` з конкретним вмістом у вигляді `SCTP`. Конструктор &mdash; це і є вміст. Даний вид конструктора називається нульарним (англ. nullary). Тип `Transport` має три нульарних конструктори. І навіть такий простий тип вже може бути нам корисним:

```haskell
checkProtocol :: Transport -> String
checkProtocol transport = case of transport
  TCP -> "that's TCP protocol."
  UDP -> "that's UDP protocol."
  SCTP -> "that's SCTP protocol."

main :: IO ()
main = putStrLn . checkProtocol $ TCP
```

В результаті побачимо:

```bash
That's protocol TCP.
```

Функція `checkProtocol` оголошена як приймаюча аргумент типу `Transport`, а застосовується вона до значення, породженому конструктором `TCP`. В даному випадку конструкція `case-of` порівнює аргумент з конструкторами. Саме тому нам не потрібна функція `otherwise`, адже ніяким іншим способом, окрім як за допомогою трьох конструкторів, значення типу `Transport` створити неможливо, а значить, один з конструкторів гарантовано співпаде з аргументом.

Тип, що складається лише з нульарных конструкторів, називають ще переліком (англ. enumeration). Конструкторів може бути скільки завгодно, в тому числі один-єдиний (хоча користь від такого типу була б невелика). Ось ще один відомий приклад:

```haskell
data Day = Sunday
         | Monday
         | Tuesday
         | Wednesday
         | Thursday
         | Friday
         | Saturday
```

Зверніть увагу на форматування, коли ментальні &laquo;АБО&raquo; вирівняні строго під знаком рівності. Такий стиль ви зустрінете в багатьох реальних Haskell-проектах.

Значення типу `Day` відображено одним з семи конструкторів. Давайте щось з ними зробимо:

```haskell
data WorkMode = FiveDays | SixDays

workingDays :: WorkMode -> [Day]
workingDays FiveDays = [ Monday
                       , Tuesday
                       , Wednesday
                       , Thursday
                       , Friday
                       ]
workingDays SixDays = [ Monday
                      , Tuesday
                      , Wednesday
                      , Thursday
                      , Friday
                      , Saturday
                      ]
```

Функція `workingDays` повертає список типу `[Day]`, і в разі п'ятиденного робочого тижня, відображеного конструктором `FiveDays`, цей перелік сформований п'ятьма конструкторами, а в разі шестиденного &mdash; шістьма конструкторами.

Користь від типів, сформованих нульарными конструкторами, не дуже велика, хоча зустрічатися з такими типами ви будете часто.

Відкрию секрет: новий тип можна визначити не тільки за допомогою ключового слова `data`, але про це дізнаємося в одному з наступних розділів.

А тепер ми можемо познайомитися з більш корисними типами.
