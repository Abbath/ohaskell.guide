# Алгебраїчні Типи Даних

АТД, або Алгебраїчні Типи Даних (англ. ADT, Algebraic Data Type), займають почесне місце в світі типів Haskell. Абсолютно переважна більшість ваших власних типів будуть алгебраїчними, і те саме можна сказати про типи з безлічі Haskell-пакетів. Алгебраїчним типом даних називають такий тип, який складений з інших типів. Ми беремо прості типи й будуємо з них, як із цеглин, типи складні, а з них &mdash; ще більш складні. Це дає нам неймовірний простір для творчості.

Залишимо мережеві протоколи і дні тижня, розглянемо такий приклад:

```haskell
data IPAddress = IPAddress String
```

Тип `IPAddress` використовує один-єдиний конструктор значення, але дещо змінилося. По-перше, імена типу і конструктора збігаються. Це цілком легально, ви зустрінете таке не раз. По-друге, конструктор вже не нульарный, а унарний (англ. unary), тому що тепер він пов'язаний з одним значенням типу `String`. І ось як створюються значення типу `IPAddress`:

```haskell
let ip = IPAddress "127.0.0.1"
```

Значення `ip` типу `IPAddress` утворено конструктором і конкретним значенням якогось типу:

```haskell
let ip = IPAddress       "127.0.0.1"

         конструктор     значення
         значення типу   типу
         IPAddress       String 

         | значення типу IPAddress |
```

Значення всередині нашого типу називають ще полем (англ. field):

```haskell
data IPAddress = IPAddress   String

     тип         конструктор поле
```

Розширимо тип `IPAddress`, зробивши його більш сучасним:

```haskell
data IPAddress = IPv4 String | IPv6 String
```

Тепер у нас два конструктори, які відповідають різним IP-версіям. Це дозволить нам створювати значення типу `IPAddress` так:

```haskell
let ip = IPv4 "127.0.0.1"
```

або так:

```haskell
let ip = IPv6 "2001:0 db8:0000:0042:0000:8a2e:0370:7334"
```

Зробимо тип ще більш зручним. Так, при роботі з IP-адресою нам часто потрібен `localhost`. І щоб явно не писати `"127.0.0.1"` і `"0:0:0:0:0:0:0:1"`, введемо ще два конструктори:

```haskell
data IPAddress = IPv4 String
               | IPv4Localhost
               | IPv6 String
               | IPv6Localhost
```

Оскільки значення `localhost` нам заздалегідь відомі, немає потреби вказувати явно. Замість цього, коли нам знадобиться `IPv4-localhost`, пишемо так:

```haskell
let ip = IPv4Localhost
```

## Витягуємо значення

Припустимо, ми створили значення `google`:

```haskell
let google = IPv4 "173.194.122.194"
```

Як же нам потім отримати конкретне значення рядка з `google`? За допомогою нашого старого друга, патерн матчінгу:

```haskell
checkIP :: IPAddress -> String
checkIP (IPv4 address) = "IP is '" ++ address ++ "'."

main :: IO ()
main = putStrLn . checkIP $ IPv4 "173.194.122.194"
```

Результат:

```bash
IP is '173.194.122.194'.
```

Поглянемо на визначення:

```haskell
checkIP (IPv4 address) = "IP is '" ++ address ++ "'."
```

Тут ми говоримо: &laquo;Ми знаємо, що значення типу `IPAddress` сформовано з конструктором і рядком&raquo;. Однак уважний компілятор зробить нам зауваження:

```bash
Match Pattern(es) are non-exhaustive
In an equation for 'checkIP':
Patterns not matched:
IPv4Localhost
IPv6 _
IPv6Localhost
```

Справді, звідки ми знаємо, що значення, до якого застосували функцію `checkIP`, було сформовано саме з допомогою конструктора `IPv4`? У нас же є ще три конструктори, і нам слід перевірити їх всіх:

```haskell
checkIP :: IPAddress -> String
checkIP (IPv4 address) = "IPv4 is '" ++ address ++ "'."
checkIP IPv4Localhost = "IPv4, localhost."
checkIP (IPv6 address) = "IPv6 is '" ++ address ++ "'."
checkIP IPv6Localhost = "IPv6, localhost."
```

З яким конструктором співпало &mdash; з таким і було створено значення. Можна, звичайно, і так перевірити:

```haskell
checkIP :: IPAddress -> String
checkIP addr = case of addr
  IPv4 address -> "IPv4 is '" ++ address ++ "'."
  IPv4Localhost -> "IPv4, localhost."
  IPv6 address -> "IPv6 is '" ++ address ++ "'."
  IPv6Localhost -> "IPv6, localhost."
```

## Конструюємо

Визначимо тип для мережевої точки:

```haskell
data Security = EndPoint String Int
```

Конструктор `Security` &mdash; бінарний, адже тут вже два значення. Створюємо звичайним способом:

```haskell
let googlePoint = EndPoint "173.194.122.194" 80
```

Конкретні значення витягаємо знову-таки через патерн матчінг:

```haskell
main :: IO ()
main = putStrLn $ "The host is:" ++ host
  where
    EndPoint host _ = EndPoint "173.194.122.194" 80

    |-- зразок  --|   |-------- значення ---------|
```

Зверніть увагу, що друге поле, відповідне порту, відображено універсальним зразком `_`, тому що в даному випадку нас цікавить тільки значення хоста, а порт просто ігнорується.

І все було б добре, але тип `Security` мені не дуже подобається. Є в ньому щось негарне. Першим полем виступає рядок, що містить IP-адресу, але навіщо нам рядок? У нас є прекрасний тип `IPAddress`, він кращий ніж безликий рядок. Це загальне правило для Haskell-розробника: чим більше інформації несе в собі тип, тим він кращий. Давайте змінимо визначення:

```haskell
data Security = EndPoint IPAddress Int
```

Тип став зрозумілішим, і ось як ми тепер будемо створювати значення:

```haskell
let google = EndPoint (IPv4 "173.194.122.194") 80
```

Красиво. Отримувати конкретні значення будемо так:

```haskell
main :: IO ()
main = putStrLn $ "The host is:" ++ ip
  where
    EndPoint (IPv4 ip) _ = EndPoint (IPv4 "173.194.122.194") 80
              ____                   ____
  
                   ==                     =================
```

Тут ми знову-таки ігноруємо порт, але значення IP-адреси витягаємо вже на основі зразка з конструктором `IPv4`.

Це простий приклад того, як з простих типів утворюються більш складні. Але складний тип зовсім не означає складну роботу з ним, патерн матчінг елегантний як завжди. А незабаром ми дізнаємося про інший спосіб роботи з полями типів, без патерн матчінгу.

Цікаво, що конструктори типів теж можна компонувати, погляньте:

```haskell
main :: IO ()
main = putStrLn $ "The host is:" ++ ip
  where
    EndPoint (IPv4 ip) _ = (EndPoint . IPv4 $ "173.194.122.194") 80
```

Це схоже на маленьке диво, але конструктори типів можна компонувати за допомогою знайомого нам оператора композиції функцій:

```haskell
(EndPoint . IPv4 $ "173.194.122.194") 80

            |     значення типу    |
            |______ IPAddress _____|
```

Вам це нічого не нагадує? Це ж так само, як ми працювали з функціями! З цього ми робимо висновок: конструктор значення можна розглядати як особливу функцію. Насправді:

```haskell
EndPoint  (IPv4 "173.194.122.194")  80

"функція" |        перший        |  другий
          |______ аргумент ______|  аргумент
```

Ми ніби застосовуємо конструктор до конкретних значень як до аргументів, в результаті чого отримуємо значення нашого типу. А раз так, ми можемо компонувати конструктори так само, як і звичайні функції, лише б їх типи були комбінованими. В даному випадку все добре: тип значення, що повертається конструктором `IPv4`, збігається з типом першого аргумента конструктора `Security`.

Ось ми й познайомилися з цими типами. Настав час дізнатися про більш зручну роботу з полями типів.
