# Вибираємо та повертаємося

У цій главі ми зустрінемося з умовними конструкціями, зазирнемо в термінал, а також дізнаємося, чому з Haskell-функцій не повертаються (втім, останнє &mdash; не більше ніж гра слів).

## Зазирнемо у зовнішній світ

Ми починаємо писати справжній код. А для цього нам знадобиться вікно у зовнішній світ. Відкриємо модуль `app/Main.hs`, знайдемо функцію `main` і напишемо в ній наступне:

```haskell
main :: IO ()
main = putStrLn "Hi, real world!"
```

Стандартна функція `putStrLn` виводить рядок на консоль. А якщо говорити строгіше, функція `putStrLn` застосовується до значення типу `String` і робить так, щоб ми побачили це значення в нашому терміналі.

Так, я вже чую питання уважного читача. Як же так, запитаєте ви, хіба ми не говорили про чисті функції в минулому розділі, які не можуть взаємодіяти з зовнішнім світом? Доведеться зізнатися: функція `putStrLn` відноситься до особливих функцій, які можуть-таки вилізти в зовнішній світ. Але про це в наступних розділах. Це дуже цікава тема, повірте мені!

І ще нам слід познайомитися з Haskell-коментарями, вони нам знадобляться:

```haskell
{-
  Я - складний багаторядковий 
  коментар, що містить
  щось
  дуже важливе!
-}
main :: IO ()
main =
  -- А я - скромний однорядковий коментар.
  putStrLn "Hi, real world!"
```

Символи `{-` і `-}` приховують багаторядковий коментар, а символ `--` починає однорядковий коментар.

Про всяк випадок нагадую команду збірки, запускається з кореня проекту:

```bash
$ stack install
```

Після збірки запускаємо проект:

```bash
$ real-exe
Hi, real world!
```

## Вибір і вихід

Вибирати всередині функції доводиться дуже часто. Існує декілька способів задання умовної конструкції. Ось базовий варіант:

```haskell
if CONDITION then EXPR1 else EXPR2
```

де `CONDITION` &mdash; логічний вираз, що дає хибу або істину, `EXPR1` &mdash; вираз, що використовується в разі `True`, `EXPR2` &mdash; вираз, що використовується в разі `False`. Приклад:

```haskell
checkLocalhost :: String -> String
checkLocalhost ip =
  -- True або False?
  if ip == "127.0.0.1" || ip == "0.0.0.0"
    -- Якщо True - йде туди...
    then "it's a localhost!"
    -- А якщо False - сюди...
    else "No, it's not a localhost."
```

Функція `checkLocalhost` застосовується до єдиного аргументу типу `String` і повертає інше значення типу `String`. Аргументом виступає рядок, що містить IP-адресу, а функція перевіряє, чи не лежить в ній localhost. Оператор `||` &mdash; стандартний оператор логічного &laquo;АБО&raquo;, а оператор `==` &mdash; стандартний оператор перевірки на рівність. Отже, якщо рядок `ip` дорівнює `127.0.0.1` або `0.0.0.0`, значить в ньому міститься localhost, і ми повертаємо перший вираз, тобто рядок `it's a localhost!`, в іншому випадку повертаємо другий вираз, рядок `No, it's not a localhost.`.

А до речі, що означає &laquo;повертаємо&raquo;? Адже, як ми дізналися, функції в Haskell не викликають (англ. call), а значить, з них і не повертаються (англ. return). І це дійсно так. Якщо напишемо:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "127.0.0.1")
```

при запуску побачимо це:

```bash
It's a localhost!
```

а якщо так:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

тоді побачимо це:

```bash
No, it's not a localhost.
```

Круглі дужки включають вираз типу `String` за схемою:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")

                 |___   вираз типу String   ___|
```

Тобто функція `putStrLn` бачить не застосування функції `checkLocalhost` до рядка, а просто вираз типу `String`. Якщо б ми опустили дужки і написали так:

```haskell
main :: IO ()
main = putStrLn checkLocalhost "173.194.22.100"
```

сталася помилка компіляції, і це цілком очікувано: функція `putStrLn` застосовується до одного аргументу, а тут їх виходить два:

```haskell
main = putStrLn        checkLocalhost "173.194.22.100"

       функція         до цього
       застосовується  аргументу...
                                      і до цього??
```

Не знаю як ви, а я не дуже люблю круглі дужки, при всій повазі до Lisp-програмістів. На щастя, в Haskell існує спосіб зменшити кількість дужок. Про цей спосіб &mdash; в одному з наступних розділів.

Так що ж з поверненням з функції? Згадаймо про рівність у визначенні:

```haskell
checkLocalhost ip =
  if ip == "127.0.0.1" || ip == "0.0.0.0"
    then "it's a localhost!"
    else "No, it's not a localhost."
```

Те, що ліворуч від знака рівності, рівне тому, що праворуч. А якщо так, то ці два коди еквівалентні:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

```haskell
main :: IO ()
main =
  putStrLn (if "173.194.22.100" == "127.0.0.1" ||
               "173.194.22.100" == "0.0.0.0"
              then "it's a localhost!"
              else "No, it's not a localhost.")
```

Ми просто замінили застосування функції `checkLocalhost` її внутрішнім виразом, підставивши замість аргументу `ip` конкретний рядок `173.194.22.100`. В результаті, у залежності від істинності або хибності перевірок на рівність, ця умовна конструкція буде замінена одним з двох виразів. В цьому і полягає ідея: значення, що повертається функцією &mdash; це її останній, підсумковий вираз. Тобто якщо вираз:

```haskell
"173.194.22.100" == "127.0.0.1" ||
"173.194.22.100" == "0.0.0.0"
```

дасть нам результат `True`, то ми переходимо до виразу з логічної гілки `then`. Якщо ж воно дасть нам `False` &mdash; ми переходимо до виразу з логічної гілки `else`. Це дає нам право стверджувати, що умовна конструкція виду:

```haskell
if True
  then "it's a localhost!"
  else "No, it's not a localhost."
```

може бути замінена на перший нередукований вираз, рядок `it's a localhost!`, а умовну конструкцію виду:

```haskell
if False
  then "it's a localhost!"
  else "No, it's not a localhost."
```

можна спокійно замінити другим нередукованим виразом, рядком `No, it's not a localhost.`. Тому код:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "0.0.0.0")
```

еквівалентний кодові:

```haskell
main :: IO ()
main = putStrLn "it's a localhost!"
```

Аналогічно, код:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

є ніщо інше, як:

```haskell
main :: IO ()
main = putStrLn "No, it's not a localhost."
```

Яким би складним не було логічне розгалуження всередині функції `checkLocalhost`, в кінцевому підсумку воно поверне/обчислить якийсь один підсумковий вираз. Саме тому з функції в Haskell не можна вийти в довільному місці, як це прийнято в імперативних мовах, адже вона не є набором інструкцій, вона є виразом, що складається з інших виразів. Ось чому функції в Haskell так просто компонувати одну з одною, і пізніше ми зустрінемо безліч таких прикладів.

## Для допитливих

Уважний читач, безсумнівно помітив незвичайне оголошення головної функції нашого проекту, функції `main`:

```haskell
main :: IO () -- Оголошення?
main = putStrLn ...
```

Якщо `IO` &mdash; це тип, що таке `()`? І чому вказаний лише один тип? Що таке `IO ()`: аргумент функції `main`, або ж те, що вона обчислює? Шкодую, але поки я змушений зберегти це в таємниці. Коли ми ближче познайомимося з Другим Китом Haskell, я неодмінно розповім про цей дивний `IO ()`.
