# Незмінність і чистота

У попередньому розділі ми ознайомилися з функціями і виразами, побачили близький зв'язок цих понять. У цьому розділі ми познайомимося з функціями ближче, а також дізнаємося, що таке &laquo;чисто функціональна&raquo; мова і чому в ній немає місця для оператора присвоювання.

## Оголошуємо і визначаємо

Застосування функції нам вже знайоме, залишилося дізнатися про оголошення та визначення, без них використовувати функцію не вийде. Пам'ятаєте функцію `square`, яка підносить свій єдиний аргумент до квадрату? Ось як виглядає її оголошення та визначення:

``haskell
square :: Int -> Int
square v = v * v
``

Перший рядок містить оголошення, другий &mdash; визначення. Оголошення (англ. declaration) &mdash; це звістка всьому світу про те, що така функція існує, ось її ім'я і ось типи, з якими вона працює. Визначення (англ. definition) &mdash; це звістка про те, що конкретно робить дана функція.

Розглянемо оголошення:

``haskell
square :: Int -> Int
``

Воно розділене подвійною двокрапкою на дві частини: зліва вказано ім'я функції, праворуч &mdash; типи, з якими ця функція працює, а саме типи аргументів і тип обчисленого, підсумкового значення. Як ви дізналися з попереднього розділу, всі дані в Haskell-програмі мають конкретний тип, а оскільки функція працює з даними, її оголошення містить типи цих даних. Типи розділені стрілками. Схематично це виглядає так:

``haskell
square :: Int   ->   Int

ім'я      тип        тип
функції   аргументу  обчисленого
                     значення
``

Таке оголошення каже нам про те, що функція `square` приймає єдиний аргумент типу `Int` і повертає значення того ж типу `Int`. Якщо ж аргументів більше одного, оголошення просто витягується. Наприклад, оголошення функції `prod`, яка повертає добуток двох цілих аргументів, могло б виглядати так:

``haskell
prod ::  Int  ->   Int   ->  Int

ім'я     тип       тип       тип
функції  першого   другого   обчисленого
         аргументу аргументу значення
``

Ідею ви зрозуміли: шукаємо крайню праву стрілку, і все лівіше від неї &mdash; це типи аргументів, а все що правіше &mdash; це тип обчисленого значення.

Ми не можемо працювати з функцією, яка нічого не обчислює. Тобто аналога C-функції `void f(int i)` в Haskell бути не може, так як це суперечить математичній природі. Однак ми можемо працювати з функцією, яка нічого не приймає, тобто з аналогом C-функції `int f(void)`. З такими функціями ми познайомимося в наступних розділах.

Тепер розглянемо визначення функції `square`:

``haskell
square v = v * v
``

Схема визначення така:

``haskell
square   v =       v * v

ім'я     ім'я      це вираз
функції  аргументу
``

А функція `prod` визначена так:

``haskell
prod     x         y    =   x * y

ім'я     ім'я      ім’я     це вираз
функції  першого   другого
         аргументу аргумент
``

Визначення теж поділено на дві частини: ліворуч від знака рівності &mdash; ім'я функції і список аргументів (імена, а не типи), розділені пробілами, а праворуч &mdash; вираз, що становить суть функції, її вміст. Іноді ці частини називають &laquo;головою&raquo; і &laquo;тілом&raquo;:

``haskell
square v       = v * v

голова функції   тіло функції
(англ. head)     (англ. body)
``

Зверніть увагу, мова тут йде саме про знак рівності, а в жодному разі не про оператор присвоювання. Ми нічого не присвоюємо, ми лише декларуємо рівність лівої і правої частин. Коли ми пишемо:

``haskell
prod x y = x * y
``

ми оголошуємо наступне: &laquo;Відтепер вираз `prod x y` тотожний виразу `x * y`&raquo;. Ми можемо безпечно замінити вираз `prod 2 5` виразом `2 * 5`, а вираз `prod 120 500` &mdash; виразом `120 * 500`, і при цьому робота програми гарантовано залишиться незмінною.

Але звідки у мене така впевненість? А ось звідки.

## Чисто функціональна

Haskell &mdash; чисто функціональна (англ. purely functional) мова. Чисто функціональним він називається тому, що центральне місце в ньому приділено чистій функції (англ. pure function). А чистою називається така функція, яка гранично чесна з нами: її вихідне значення цілком визначається її аргументами і більше нічим. Це і є функція в математичному сенсі. Згадаймо функцію `prod`: коли на вході числа `10` і `20` &mdash; на виході завжди буде `200`, і ніщо не здатне перешкодити цьому. Функція `prod` є чистою, а тому характеризується відсутністю сторонніх ефектів (англ. side effects): вона не здатна зробити нічого, крім повернення добутку двох своїх аргументів. Саме тому чиста функція гранично надійна, адже вона не може зробити нам ніяких сюрпризів.

Скажу більше: чисті функції не бачать навколишній світ. Взагалі. Вони не можуть вивести текст на консоль, їх не можна змусити обробити HTTP-запит, вони не вміють дружити з базою даних і прочитати файл вони нездатні. Вони є річчю в собі.

А щоб здивувати вас ще більше, відкрию ще один секрет Haskell.

## &laquo;Присвоювання? Ні, не чув&hellip;&raquo;

У світі Haskell немає місця для оператора присвоювання. Втім, цей факт дивний лише на перший погляд. Замислимося: якщо кожна функція в кінцевому підсумку є виразом, обчислюваним за допомогою застосування якихось інших функцій до якихось інших аргументів, тоді нам просто не потрібно нічого нічому присвоювати.

Згадаймо, що присвоювання (англ. assignment) прийшло до нас з імперативних мов. Імперативне програмування (англ. imperative programming) &mdash; це напрямок у розробці, що об'єднує кілька парадигм програмування, однією з яких є знаменита об'єктно-орієнтована парадигма. В рамках цього напряму програма сприймається як набір інструкцій, виконання яких нерозривно пов'язане із зміною стану (англ. state) цієї програми. Ось чому в імперативних мовах обов'язково присутнє поняття &laquo;змінної&raquo; (англ. variable). А раз є змінні &mdash; повинен бути оператор присвоювання. Коли ми пишемо:

``c
coeff = 0.569;
``

ми тим самим наказуємо: &laquo;Візьми значення `0.569` і перезапиши ним те значення, яке вже містилося в змінній `coeff` до цього&raquo;. І перезаписувати це значення ми можемо багато разів, а отже, ми змушені уважно відслідковувати поточний стан змінної `coeff`, так само як і стан всіх інших змінних в нашому коді.

Однак існує принципово інший підхід до розробки, а саме декларативне програмування (англ. declarative programming). Даний напрямок також включає в себе кілька парадигм, однією з яких є функціональна парадигма, що знайшла своє втілення в Haskell. При цьому підході програма сприймається вже не як набір інструкцій, а як набір виразів. А оскільки вирази обчислюються шляхом застосування функцій до аргументів (тобто, по суті, до інших виразів), там немає місця ні для змінних, ні для оператора присвоювання. Всі дані в Haskell-програмі, будучи створеними один раз, вже не можуть бути змінені. Тому нам не потрібен не тільки оператор присвоювання, але і ключове слово `const`. І коли в Haskell-коді ми пишемо:

``haskell
coeff = 0.569
``

ми просто оголошуємо: &laquo;Відтепер значення `coeff` дорівнює `0.569`, і так воно буде завжди&raquo;. Ось чому в Haskell-коді символ `=` &mdash; це знак рівності в математичному сенсі, і з присвоюванням він не має нічого спільного.

Упевнений, ви здивовані. Як же можна написати реальну програму на мові, в якій можна редагувати дані? Який зиск від цих чистих функцій, якщо вони не здатні ні файл прочитати, ні запит по мережі відправити? Виявляється, користь є, і на Haskell можна написати дуже навіть реальну програму. За прикладом далеко ходити не буду: сама ця книга побудована за допомогою програми, написаної на Haskell, про що я докладніше розповім в наступних главах.

А тепер, щоб не мучити вас питаннями без відповіді, ми почнемо ближче знайомитися з Китами Haskell, і деталі великої головоломки поступово складуться в красиву картину.

## Для допитливих

У процесі роботи Haskell-програми в пам'яті створюється безліч різних даних, адже ми постійно будуємо нові дані на основі вже наявних. За їх своєчасне знищення відповідає збирач сміття (англ. garbage collector, GC), вбудований в компілятор GHC.
